<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/max.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/max.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/max.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/max.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/max.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/max.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/max.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/max.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
	<a href="https://github.com/isMaxaaa" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/max.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/max.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/max.github.io/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/max.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/max.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/max.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/max.github.io/2020/04/20/并发工具Excutor框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/max.github.io/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/max.github.io/2020/04/20/并发工具Excutor框架/" itemprop="url">并发工具Excutor框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-20T22:01:25+08:00">
                2020-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/max.github.io/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Excutor框架解析"><a href="#Excutor框架解析" class="headerlink" title="Excutor框架解析"></a>Excutor框架解析</h3><h4 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h4><p>线程的使用提高了程序的执行效率，能同时处理多个任务。在网络编程时，常使用多线程处理客户端的连接，有这样一个需求：当客户端连接请求很多时，如果给每个请求都去主动创建一个线程，就存在以下3个问题：</p>
<ol>
<li>线程生命周期的开销非常高。线程创建时，需要JVM和底层操作系统提供一个辅助操作，尤其当大量线程创建时，创建每个线程时将消耗大量的计算资源。</li>
<li>资源消耗。活跃的线程会消耗系统资源，比如内存，当运行的线程的数量大于可用的cpu核处理器数量，就会有多余的线程处于闲置状态，会占用大量的内存，大量的线程会增大CPU的竞争，产生性能消耗。</li>
<li>稳定性。由于内存的空间有限制，每个线程创建时，需要提供栈空间等，如果线程数量大，可能超出内存大小，抛出OutOfMemory异常。</li>
</ol>
<p>为解决以上问题，就产生了线程池，能够自动帮我们管理线程。主要有3个好处：</p>
<ol>
<li>降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁的损耗。</li>
<li>提高响应速度，当任务到达时，任务可以不需要等待线程创建启动直接执行。</li>
<li>提高线程的可管理性，线程池可以统一对线程进行分配、调优、监控，提高线程的可管理性。</li>
</ol>
<p>Java使用线程池的核心就是Excutor框架，接下来就对这个框架进行分析。</p>
<h4 id="Excutor相关类图"><a href="#Excutor相关类图" class="headerlink" title="Excutor相关类图"></a>Excutor相关类图</h4><p><img src="/max.github.io/2020/04/20/并发工具Excutor框架/Excutor1.png" alt="Excutor1"></p>
<ul>
<li>Executor接口采用了<strong>命令设计模式</strong>，让任务的提交与任务的执行策略解耦开来。</li>
<li>ExecutorService接口扩展了Executor，包含了Excutor的生命周期，以及任务的提交功能。</li>
<li>AbstractExecutorService抽象类使用了newTaskFor方法实现了提交的功能，但submit方法中的execute抽象方法并没有实现，只定义了方法实现逻辑，execute留给子类实现，其实这也是模板方法设计模式，命令设计模式与之结合，可以减少扩展类的规模。</li>
<li>ScheduledExecutorService接口扩展了ExecutorService接口，增加了定时任务执行功能。</li>
<li>ForkJoinPool利用多Cpu的特性，将一个大任务分解成多个小任务，然后同时执行，最后再合并计算结果。</li>
<li>ThreadPoolExecutor线程池核心的实现。</li>
<li>ScheduledThreadPoolExecutor调度线程池的实现。</li>
</ul>
<h4 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Executor &#123;</span><br><span class="line">	 void execute(Runnable command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Executor接口只有一个方法execute，任务是Runnable类。在AbstractExecutorService类中，模板方法submit定义了逻辑，但实现在ThreadPoolExecutor类。</p>
<h5 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface ExecutorService extends Executor &#123;</span><br><span class="line">	 void shutdown();</span><br><span class="line">	 List&lt;Runnable&gt; shutdownNow();</span><br><span class="line">	 boolean isShutdown();</span><br><span class="line">	 boolean isTerminated();</span><br><span class="line">	 boolean awaitTermination(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException;</span><br><span class="line">   &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">   &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">	 Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">	 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        throws InterruptedException;</span><br><span class="line">   &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException;</span><br><span class="line">   &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        throws InterruptedException, ExecutionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Executor以异步方式执行任务，所以在某一时刻，之前提交的任务不是立即完成的，可能处于运行中，可能处于任务队列中，还可能已经完成。关闭的时候，可以”平缓”地关闭，之前提交了的任务继续执行完，但不能再添加新的任务。也可以”粗暴“地关闭，所有任务都停止执行。ExecutorService提供了管理Executor生命周期的方法。</p>
<blockquote>
<p>Executor的生命周期有三种状态：运行、关闭、已终止。</p>
</blockquote>
<p>当Executor创建时就处于运行状态。</p>
<p><code>shutdown()</code>平缓地关闭Executor，不再接受新的任务，同时等待之前提交的任务执行完成，包括还未开始执行的任务。</p>
<p><code>shutdownNow()</code>粗暴地关闭Executor，尝试取消所有运行中的任务，并且不再启动等待队列中的任务，也不接受新的任务。</p>
<p>isShutdown()可以判断Executor是否为关闭状态，至于关闭后，如果有新提交的任务，将由拒绝执行处理器（Rejected Execution Handler）来处理，执行对应的执行策略。等所有任务都完成后，Executor进入终止状态。可以调用awaitTermination()来等待Executor进入等待状态，也可以调用isTerminated来轮询Executor是否为终止状态。</p>
<h5 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h5><p>AbstractExecutorService抽象类实现了ExecutorService部分方法，使用newTaskFor封装任务，实现了submit的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将Runnable和指定结果封装为一个FutureTask任务</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T    value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将Callable封装为一个FutureTask任务</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Runnable任务的提交，没有指定返回结果</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//没有执行结果，RunnableFuture的泛型为Void</span></span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//执行封装的任务，留给子类实现</span></span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带有指定返回结果的Runnable任务提交</span></span><br><span class="line">     <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Callable任务提交</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，任务提交时，都是先将Runnable、Callable任务封装为一个异步任务对象，可以返回任务执行结果的，然后再execute执行任务。并且submit返回这个异步任务对象。可以通过Future的get()方法返回结果，Runnable任务返回结果比较简单，可以立即返回。但是Callable任务不一定能立即返回，需要看任务执行情况，并且get方法会使当前线程阻塞，直到任务执行完成。</p>
<blockquote>
<p>再来看下invokeAll方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//创建一个包含返回结果Future对象的集合</span></span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">    <span class="comment">//定义一个布尔对象，是否完成</span></span><br><span class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//对所有的任务封装成RunnableFuture，加入返回结果集合中，再执行</span></span><br><span class="line">        <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks) &#123;</span><br><span class="line">            RunnableFuture&lt;T&gt; f = newTaskFor(t);</span><br><span class="line">            futures.add(f);</span><br><span class="line">            execute(f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历返回结果Future集合，判断是否任务执行完成，如果没有完成，调用get方法，</span></span><br><span class="line">        <span class="comment">//阻塞当前线程，等待该任务执行完成。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++) &#123;</span><br><span class="line">            Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    f.get();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等所有任务执行完成后，done为true</span></span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> futures;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//如果任务没有都完成，调用cancel()方法尝试取消所有任务</span></span><br><span class="line">        <span class="keyword">if</span> (!done)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">                futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>invokeAll的超时方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                     <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//转化timeout参数</span></span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks)</span><br><span class="line">            futures.add(newTaskFor(t));</span><br><span class="line">        <span class="comment">//得到任务超时的时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanos;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = futures.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依次执行所有任务，预计超时时间减去当前时间，如果小于零即超时了，立即返回当</span></span><br><span class="line">        <span class="comment">//前future集合，但是可能还有任务没有execute执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            execute((Runnable)futures.get(i));</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> futures;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历返回结果future集合，如果任务没有完成，并且执行任务时出现超时使有任务没</span></span><br><span class="line">        <span class="comment">//执行，立即返回future集合。如果没超时，使用get()超时方法，超时时间为之前执</span></span><br><span class="line">        <span class="comment">//行任务剩余的超时时间减去当前时间，并且每次更新</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> futures;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    f.get(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">                    <span class="keyword">return</span> futures;</span><br><span class="line">                &#125;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> futures;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!done)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">                futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><blockquote>
<p>简单分析了Executor相关接口，接下来看下线程池 ThreadPoolExecutor的核心实现</p>
</blockquote>
<h5 id="参数变量"><a href="#参数变量" class="headerlink" title="参数变量"></a>参数变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存任务的阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">    <span class="comment">//全局唯一lock锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//存放工作线程的set集合，每个work工作线程包括一个任务和对应的执行线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line">    <span class="comment">//支持awaitTerminate操作的条件对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line">    <span class="comment">//记录线程池最大的工作线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line">    <span class="comment">//计数器已经完成的任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line">    <span class="comment">//线程工厂，用来创建工作线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line">    <span class="comment">//拒绝策略执行器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line">    <span class="comment">//超时时间，工作线程处于空闲时使用，如果等待工作超过了超时时间，就会标记为可回收。</span></span><br><span class="line">    <span class="comment">//而且如果此时线程池大小超过了集合核心线程数量，这个线程会被立即终止。</span></span><br><span class="line">  	<span class="comment">//可以适当调大这个时间，提高线程的利用率。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line">    <span class="comment">//是否允许使用keepAliveTime超时</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line">    <span class="comment">//线程池的核心数量，默认情况下即时核心线程处于空闲状态也不回收，除非设置allow</span></span><br><span class="line">    <span class="comment">//CoreThreadTimeOut为true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line">    <span class="comment">//线程池能容纳的最大线程数，如果有更多的任务就会执行拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述参数就是线程池的核心参数，几乎构建了线程池的基本运行。除此之外，还有一组状态参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//用来保存线程池的状态，前3位是运行状态，后29位是线程的数量</span><br><span class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">private static final int COUNT_BITS = Integer.SIZE - 3;</span><br><span class="line">//容量为2的29次方减1</span><br><span class="line">private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">// runState is stored in the high-order bits</span><br><span class="line">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int STOP       =  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">// Packing and unpacking ctl</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<p>这里需要了解下计算机怎么存储整数的相关知识。</p>
<blockquote>
<p>学过计算机原理都知道，计算机存储整数都是存储补码的。那为什么不存储原码或者反码呢？</p>
</blockquote>
<p>先解释下原码、反码、补码是什么</p>
<ul>
<li>原码：在数值前面增加了一位符号为，0表示正数，1表示负数，其余位表示数值大小。</li>
<li>反码：正数的反码和原码相同，负数的反码是对其原码逐位取反，但符号位除外。</li>
<li>补码：正数的补码与其原码相同，负数的补码是对该负数的反码加一。0的原反补码相同为00000000。</li>
</ul>
<p>比如2，原码00000010，反码00000010，补码00000010。</p>
<p>比如-2，原码10000010，反码11111101，补码11111110。</p>
<p>如果计算机使用原码，比如1+(-1)=00000001+（10000001）=-2，这是不正确的</p>
<p>如果使用反码，问题出在0上面，0就可以用00000000也可以用（-0）11111111表示，会使0有正负之分。</p>
<p>使用补码就不会出现上述问题。</p>
<blockquote>
<p>再回过来看线程池运行参数</p>
</blockquote>
<p>RUNNING = 1110 0000 0000 0000 , 表示接受新任务并继续处理阻塞队列的任务</p>
<p>SHUTDOWN = 0000 0000 0000 0000,表示不接受新任务，但是继续处理阻塞队列的任务</p>
<p>STOP  = 0010 0000 0000 0000,表示不接受新任务，不继续处理阻塞队列的任务，尝试中断正在执行的任务</p>
<p>TIDYING = 0100 0000 0000 0000,表示所有任务都完成，线程数被回收，等待线程池终止</p>
<p>TERMINATED = 1100 0000 0000 0000,表示线程池处于终止状态</p>
<p>0001 1111 1111 1111</p>
<p>1110000</p>
<h5 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h5><blockquote>
<p>接着看下ThreadPoolExecutor的构造器</p>
</blockquote>
<p>有三种构造器，可以使用默认的线程工厂、拒绝策略执行器，也可以定制它们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认线程工厂，拒绝策略执行器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用定制的线程工厂</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用定制的拒绝策略执行器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断参数的正确性</span></span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//垃圾回收时的参数</span></span><br><span class="line">        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="comment">//线程池的核心参数赋值</span></span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="饱和策略执行器"><a href="#饱和策略执行器" class="headerlink" title="饱和策略执行器"></a>饱和策略执行器</h5><p>拒绝策略也称饱和策略，指队列和线程池都满了，需要一个策略处理新的任务。默认是AbortPolicy，直接抛出异常。总共有四种饱和策略：</p>
<ul>
<li>AbortPolicy，直接抛出异常</li>
<li>DiscardPolicy，不处理直接丢弃掉</li>
<li>CallerRunsPolicy，使用调用者所在的线程执行任务</li>
<li>DiscardOldestPolicy，丢弃队列里最近的一个任务，并执行当前任务。</li>
</ul>
<p>这四种饱和策略执行器，在线程池中是静态内部类实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                             <span class="string">" rejected from "</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h5><p>向线程池中提交任务时，会执行execute方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//ctl.get()原子操作，获得线程池当前状态变量，初始是1110 0000 0000 0000</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//workerCountOf(c)计算的是线程池当前线程数量大小，初始是0</span></span><br><span class="line">    <span class="comment">//小于核心线程池数量，addWorker()创建工作线程执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//isRunning()判断线程池当前是否处于RUNNING运行状态，workQueue.offer()向阻塞队列中提交任务</span></span><br><span class="line">    <span class="comment">//再进行一次运行状态检测，防止线程池状态发生变化，并且线程池关闭，使用饱和策略执行任务</span></span><br><span class="line">    <span class="comment">//否则，如果当前工作线程数量为0，addWorker()创建一个不包含任务的非核心工作线程，只要创建了工作</span></span><br><span class="line">    <span class="comment">//线程，就能从阻塞队列中取出任务执行</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果阻塞队列任务满了，addWorker创建非核心工作线程执行任务</span></span><br><span class="line">    <span class="comment">//如果当前线程数大于maximumPoll,则执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>到这里可以完整地介绍下线程池的运行原理</p>
</blockquote>
<p><img src="/max.github.io/2020/04/20/并发工具Excutor框架/%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7Excutor%E6%A1%86%E6%9E%B6%5CExcutor2.png" alt="Excutor2"></p>
<p><code>execute()</code>向线程池中提交任务时</p>
<ol>
<li>如果当前工作线程数量小于corePoolSize核心线程数量，需要创建新的工作线程执行任务。</li>
<li>如果当前工作线程数量等于大于corePoolSize，加入到阻塞队列BlockingQueue中。每次创建工作线程时，都会尝试从阻塞队列中获取任务。</li>
<li>如果阻塞队列满了，则创建新的非核心工作线程执行任务。</li>
<li>如果当前工作线程数量大于maximumPoolSize线程池工作线程的最大值，则使用RejectedExcutionHandler拒绝策略执行器处理这个任务。</li>
</ol>
<h5 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h5><p>在<code>execute()</code>中，创建工作线程时使用addWorker()，addWorker(Runnable firstTask, boolean core)，有两个参数，第一个参数是执行的任务，第二个参数是是否为核心线程，true代表创建核心线程，false代表创建非核心线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">//循环处理，直到CAS操作成功增加工作线程</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//c是线程池的状态变量，rs是线程池的运行状态</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果运行状态大于等于SHUTDOWN,即stop、tidying、terminated时，这是第一个条件</span></span><br><span class="line">        <span class="comment">// 第二个条件，如果运行状态大于SHUTDOWN，返回false。</span></span><br><span class="line">        <span class="comment">// 如果运行状态是SHUTDOWN,并且firstTask任务为空，即创建一个空任务的线程从阻塞队列获取任务，</span></span><br><span class="line">        <span class="comment">// 但是如果阻塞队列的任务也为空，即返回false，也没有必要创建线程。</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			 <span class="comment">//状态条件判断完成后，进行CAS增加线程数量</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">//如果大于最大容量或者创建核心线程时，大于核心线程数量，创建非核心线程时，大于最大数量</span></span><br><span class="line">            <span class="comment">//返回false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//CAS线程数量后的操作，真正创建线程</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//工作线程对象</span></span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//new一个工作线程对象，传递任务对象</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="comment">//获取全局唯一lock锁</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取线程池运行状态</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">//如果是RUNNING,或者创建一个空的任务的线程</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">//检查线程是否是活跃的</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) </span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">//向包含工作线程集合中添加线程对象</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">//如果已经创建出的线程大于largestPoolSize，更新值</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    <span class="comment">//成功添加</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果成功添加，工作线程启动，执行任务，任务成功启动</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//如果任务没有成功启动，从works集合删除这个线程对象，并且CAS线程数量减一</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先进行线程池状态变量的判断，如果运行状态大于等于SHUTDOWN,并且阻塞队列的任务为空时，就返回false。然后进行CAS操作，对线程数量增1。</p>
<p>接着进行创建工作线程，如果是RUNNING状态或者是SHUTDOWN状态且任务为空时，启动线程。如果线程启动失败，执行addWorkerFailed操作。</p>
<blockquote>
<p>至此，execute涉及的操作都差不多分析完了，接下来看下Work工作线程内部类。</p>
</blockquote>
<h5 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">       <span class="comment">// 工作线程对象</span></span><br><span class="line">       <span class="keyword">final</span> Thread thread;</span><br><span class="line">       <span class="comment">//执行的任务对象</span></span><br><span class="line">       Runnable firstTask;</span><br><span class="line">       <span class="comment">//已经完成的任务计数器</span></span><br><span class="line">       <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">         Worker(Runnable firstTask) &#123;</span><br><span class="line">            <span class="comment">//AQS设置状态</span></span><br><span class="line">            setState(-<span class="number">1</span>); </span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="comment">//使用线程工厂创建线程</span></span><br><span class="line">            <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runWorker(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">     ...... </span><br><span class="line">     <span class="comment">//其它重写AQS的方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个问题，为什么不直接在execute创建线程，而是封装成Worker？</p>
<p>其实是为了更好地解决中断，使用AQS实现，当运行时上锁就不能中断。</p>
<blockquote>
<p>runWorker()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//new Worker()时，state=-1，此时unlock()是调用tryRelease()方法，将state置0，在interruptIfSta</span></span><br><span class="line">    <span class="comment">//rted（）中只有state&gt;=0,才允许中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果当前任务不为空或者从阻塞队列中获取到了任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//工作线程获取lock锁，不是为了防止并发任务，是为了线程池的shutdown()时不终止正在运行</span></span><br><span class="line">            <span class="comment">//的worker线程</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">//线程池状态&gt;STOP时，且当前线程没有设置中断标志，当前线程中断</span></span><br><span class="line">            <span class="comment">//如果一开始线程池状态小于STOP时，当前线程但是当前线程已被中断，但又清除了中断标志，</span></span><br><span class="line">            <span class="comment">//再次判断线程池状态是否是大于等于STOP,如果是当前线程中断</span></span><br><span class="line">            <span class="comment">//如果不是，不做操作，此时中断位已经被清除了</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                <span class="comment">//判断中断位是否清除</span></span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                <span class="comment">//当前线程中断</span></span><br><span class="line">                wt.interrupt();  </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行前的操作，留给子类实现</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//执行任务</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//处理worker线程的退出</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里涉及到getTask()，再看下getTask()获取任务的实现</p>
<blockquote>
<p>getTask()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">    <span class="comment">//循环操作</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取线程池状态变量和运行状态参数</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果运行状态大于等于SHUTDOWN，并且大于等于STOP或者阻塞队列为空</span></span><br><span class="line">        <span class="comment">//CAS线程数量减一，即阻塞队列没有任务</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是非核心线程或者允许了线程空闲超时，timed为true</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果当前线程数量大于maximumPoolSize或者设置了定时超时</span></span><br><span class="line">        <span class="comment">//并且阻塞队列中没有任务或者当前仍有工作线程，CAS操作减一线程数量，减一次就行</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果定时了，则从阻塞队列中超时获取任务，如果没定时，则直接teke操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">//没有返回说明超时，进行下一次循环，每次工作线程数量都减一</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">//发生中断，将timeOut为false</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/max.github.io/2020/04/13/并发工具——阻塞队列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/max.github.io/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/max.github.io/2020/04/13/并发工具——阻塞队列/" itemprop="url">并发工具——阻塞队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-13T18:54:56+08:00">
                2020-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/max.github.io/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="并发工具——阻塞队列"><a href="#并发工具——阻塞队列" class="headerlink" title="并发工具——阻塞队列"></a>并发工具——阻塞队列</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>并发编程中使用生产者——消费者模式可以解决大多数并发的问题，在这种模式下，通过平衡生产者线程生产数据和消费者线程消费数据的速度，可以提高程序整体处理数据的速度。怎么平衡呢？就是阻塞队列当作缓冲区，生产者生产完数据直接放到阻塞队列中，等待消费者从中拿取数据。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>阻塞队列充当了一个缓冲区，生产者线程不断向队列中添加元素，消费者线程不断从队列中拿取元素。由于队列容量是有限的，当队列已满，生产者线程就会被阻塞，必须等消费者线程获取一个元素才能被唤醒。当队列为空，消费者线程就会被阻塞，必须等生产者线程放入队列元素才能被唤醒。</p>
<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><p>BlockingQueue接口继承关系如下</p>
<p><img src="/max.github.io/2020/04/13/并发工具——阻塞队列/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%971.png" alt="阻塞队列1"></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">抛出异常</th>
<th align="center">特殊值</th>
<th align="center">阻塞</th>
<th align="center">超时</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入</td>
<td align="center">add(E e)</td>
<td align="center">offer(E e)</td>
<td align="center">put(E e)</td>
<td align="center">offer(E e, long timeout, TimeUnit unit)</td>
</tr>
<tr>
<td align="center">移除</td>
<td align="center">remove(E e)</td>
<td align="center">poll()</td>
<td align="center">take()</td>
<td align="center">poll(long timeout, TimeUnit unit)</td>
</tr>
<tr>
<td align="center">返回</td>
<td align="center">element()，返回队首元素</td>
<td align="center">peek()</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li><p>抛出异常：当队列满时，再向队列插入元素会抛出异常，队列为空，从队列获取元素会抛出异常。</p>
</li>
<li><p>特殊值：往队列中插入元素时，如果插入成功返回true。从队列中取元素，如果没有返回null。</p>
</li>
<li><p>阻塞：当阻塞队列满时，如果生产者线程往队列中put元素，队列会阻塞生产者线程，直到队列可用或者响应中断退出。当队列为空，消费者take元素，队列会阻塞消费者线程，直到队列可用。</p>
</li>
<li><p>超时：队列满时或为空，队列阻塞线程，如果超过了一定时间，线程会自动退出。</p>
</li>
</ul>
<h5 id="常用的阻塞队列"><a href="#常用的阻塞队列" class="headerlink" title="常用的阻塞队列"></a>常用的阻塞队列</h5><table>
<thead>
<tr>
<th align="center">队列</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ArrayBlockingQueue</td>
<td align="center">一个由数组结构组成的有界阻塞队列</td>
</tr>
<tr>
<td align="center">LinkedBlockingQueue</td>
<td align="center">一个由链表结构组成的有界阻塞队列</td>
</tr>
<tr>
<td align="center">PriorityBlockingQueue</td>
<td align="center">一个支持优先级排序的无界阻塞队列</td>
</tr>
<tr>
<td align="center">DelayQueue</td>
<td align="center">一个使用优先级队列实现的无界阻塞队列</td>
</tr>
<tr>
<td align="center">SynchronousQueue</td>
<td align="center">一个不存储元素的阻塞队列</td>
</tr>
<tr>
<td align="center">LinkedTransferQueue</td>
<td align="center">一个由链表结构组成的无界阻塞队列</td>
</tr>
<tr>
<td align="center">LinkedBlockingDeque</td>
<td align="center">一个由链表结构组成的双向阻塞队列</td>
</tr>
</tbody></table>
<h6 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h6><p>ArrayBlockingQueue是由数组实现的阻塞队列，看下包含的字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承了AbstractQueue，实现序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//保存队列元素的数组</span></span><br><span class="line">		<span class="keyword">final</span> Object[] items;</span><br><span class="line">		<span class="comment">//下一次take元素的索引</span></span><br><span class="line">		<span class="keyword">int</span> takeIndex;</span><br><span class="line">		<span class="comment">//下一次put元素的索引</span></span><br><span class="line"> 		<span class="keyword">int</span> putIndex;</span><br><span class="line"> 		<span class="comment">//队列中元素的数量</span></span><br><span class="line">		<span class="keyword">int</span> count;</span><br><span class="line">	  <span class="comment">//唯一可重入锁</span></span><br><span class="line">		<span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="comment">//用来阻塞take操作</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    <span class="comment">//用来阻塞put操作</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>看下构造函数</li>
</ul>
<p>构造函数有三种，ArrayBlockingQueue(int )、ArrayBlockingQueue(int, boolean)、 ArrayBlockingQueue(int , boolean,  Collection&lt;? extends E&gt; )。默认fair为false，代表非公平锁模式。</p>
<p>公平锁模式就是当线程退出阻塞时，先被阻塞的线程先访问队列。非公平锁模式是阻塞的线程可以随机竞争访问阻塞队列，提高了吞吐率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加元素操作，add、offer</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//在队列尾部添加元素，队列满时抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//先加锁，再添加。队列满时返回false。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      checkNotNull(e);</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (count == items.length)</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              enqueue(e);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">      <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">      <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">      <span class="comment">//数组尾部添加元素</span></span><br><span class="line">      items[putIndex] = x;</span><br><span class="line">      <span class="comment">//如果添加元素满了，putIndex设为0</span></span><br><span class="line">      <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">          putIndex = <span class="number">0</span>;</span><br><span class="line">      count++;</span><br><span class="line">      <span class="comment">//如果take操作线程被阻塞，condition唤醒进行take操作的线程</span></span><br><span class="line">      notEmpty.signal();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>put操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//线程被中断时会抛出异常</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="comment">//队列的元素如果已经满了，put操作对应的condition会阻塞当前线程，等待被take操作的线程唤醒</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">      	<span class="comment">//唤醒后进行enqueue()</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>take操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">      <span class="comment">//线程被中断会抛出异常</span></span><br><span class="line">      lock.lockInterruptibly();</span><br><span class="line">      <span class="comment">//当前队列元素为空时，take操作对应的condition会阻塞当前线程，等待被offer、put操作的线程唤醒</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">              notEmpty.await();</span><br><span class="line">        	<span class="comment">//获取元素并返回</span></span><br><span class="line">         <span class="keyword">return</span> dequeue();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">      <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">      <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      <span class="comment">//获取元素并赋值</span></span><br><span class="line">      E x = (E) items[takeIndex];</span><br><span class="line">      <span class="comment">//将原来的位置赋为空</span></span><br><span class="line">      items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//如果元素都已经获取完了，takeIndex设为空</span></span><br><span class="line">    	<span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">          takeIndex = <span class="number">0</span>;</span><br><span class="line">      count--;</span><br><span class="line">      <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">          itrs.elementDequeued();</span><br><span class="line">      <span class="comment">//唤醒put操作对应的线程</span></span><br><span class="line">      notFull.signal();</span><br><span class="line">      <span class="keyword">return</span> x;	</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>总结</li>
</ul>
<ol>
<li>初始化阻塞队列，构造器默认可重入锁是非公平性的。</li>
<li>一个线程进行put操作，如果队列的元素已经满了，put操作的condition对象会阻塞该线程。等待进行take操作的其他线程，获取元素然后唤醒该线程。同理，进行take操作，如果队列的元素为空，take操作的condition对象会阻塞线程，等待被put操作的其它线程唤醒。</li>
</ol>
<h6 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h6><p>LinkedBlockingQueue是基于链表构成的有界的阻塞队列。</p>
<ul>
<li>看下字段属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//链表的最大长度</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当前的元素数量，原子计数器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//链表的头节点</span></span><br><span class="line">	<span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//链表的尾节点</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//take、poll操作对应的lock锁</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//阻塞take操作的condition对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//put、offer操作对应的lock锁</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//阻塞put操作的condition对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//内部类Node，链表的元素</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">			 <span class="comment">//链表元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">//下一个链表元素</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node(E x) &#123; item = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>看下构造器</p>
<p>三种构造器，LinkedBlockingQueue()、LinkedBlockingQueue(Collection&lt;? extends E&gt; )、        LinkedBlockingQueue(int )，默认capacity是Integer.MAX_VALUE（2^31^-1）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//设置元素容量</span></span><br><span class="line">  	<span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    <span class="comment">//初始化头、尾节点，元素为空</span></span><br><span class="line">  	last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="comment">//获取put操作对应的lock锁</span></span><br><span class="line">  	putLock.lock(); <span class="comment">// Never contended, but necessary for visibility</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (n == capacity)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">            enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//原子操作设置元素的数量</span></span><br><span class="line">        count.set(n);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>put操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></span><br><span class="line">    <span class="comment">// holding count negative to indicate failure unless set.</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//创建一个节点，包含要添加的元素</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">//获取put操作对应lock锁，可响应中断</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//如果当前元素数量等于链表最大长度，put操作对应的condition阻塞当前线程，等待take操作线程唤醒</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//元素添加到链表尾部</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">//原子操作进行元素数量加一，并且返回当前元素数量</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">//如果还可以再添加元素，put操作对应的condition唤醒被put操作阻塞的线程</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果原来的链表为空，现在刚添加元素，则唤醒被take操作阻塞的线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取take操作对应的锁，take操作对应的condition对象唤醒被take操作阻塞的线程</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">        takeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//链表的尾部添加元素，并赋为新的尾节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">        <span class="comment">// assert last.next == null;</span></span><br><span class="line">        last = last.next = node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>take操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    <span class="comment">//获取take操作对应的lock锁，可响应中断</span></span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//如果当前链表元素为空，take操作对应的condition阻塞当前线程，等待put操作进行操作直到元素满时</span></span><br><span class="line">       <span class="comment">//唤醒当前线程</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移除链表头部第一个元素</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="comment">//如果现在链表还有元素，take操作对应的condition唤醒被take操作阻塞的线程</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果操作之前的链表元素满时，put操作对应的condition唤醒被put操作阻塞的线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">        <span class="comment">// assert head.item == null;</span></span><br><span class="line">        <span class="comment">//获取链表头节点</span></span><br><span class="line">        Node&lt;E&gt; h = head;</span><br><span class="line">        <span class="comment">//获取链表头节点的第一个元素并保存</span></span><br><span class="line">        Node&lt;E&gt; first = h.next;</span><br><span class="line">        <span class="comment">//将原来的head节点next指向自己</span></span><br><span class="line">        h.next = h; <span class="comment">// help GC</span></span><br><span class="line">        <span class="comment">//head重新指向保存的下一个节点，原来的head节点会被GC</span></span><br><span class="line">        head = first;</span><br><span class="line">        E x = first.item;</span><br><span class="line">        <span class="comment">//新的head头节点元素设为null</span></span><br><span class="line">        first.item = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//返回head节点的第一个元素</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">        putLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notFull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            putLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h6><p>PriorityBlockingQueue阻塞队列是具有优先级顺序的无界特点，优先级表现是元素需要实现Comparable接口，比较结果小的元素排在队列前面。无界表现在队列可以扩容很大，最大可以扩容到Integer    .MAX_VALUE-8(2^31^-9)。队列元素出队和DelayQueue一样，基于PriorityQueue实现，从队头出列，并且元素重新构成最小堆。</p>
<ul>
<li>字段属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">     <span class="comment">//队列元素默认数量</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line">     <span class="comment">//队列扩容的最大数量</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">     <span class="comment">//底层真正保存元素的数组</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue; </span><br><span class="line">     <span class="comment">//队列元素的数量</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size; </span><br><span class="line">     <span class="comment">//队列元素排序的指定比较器</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">     <span class="comment">//唯一可重入锁</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">     <span class="comment">//阻塞take操作的条件对象</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">     <span class="comment">//take操作的CAS锁</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> allocationSpinLock;</span><br><span class="line">     <span class="comment">//序列化操作使用</span></span><br><span class="line">     <span class="keyword">private</span> PriorityQueue&lt;E&gt; q;</span><br><span class="line">     <span class="comment">//UNSAFE类，用来构建CAS操作</span></span><br><span class="line">     <span class="comment">// Unsafe mechanics</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> allocationSpinLockOffset;</span><br><span class="line">     <span class="comment">//static静态块初始时，UNSAFE.objectFieldOffset方法转化allocationSpinLock字段</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = PriorityBlockingQueue.class;</span><br><span class="line">            allocationSpinLockOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"allocationSpinLock"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  	</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造器传入默认容量，比较器为null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入自定义comparator比较器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">        <span class="comment">//队列数组初始化</span></span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>put操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    offer(e); <span class="comment">// never need to block</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">//获取lock锁</span></span><br><span class="line">  			lock.lock();</span><br><span class="line">        <span class="comment">//定义队列size、capacity、array数组局部变量</span></span><br><span class="line">  			<span class="keyword">int</span> n, cap;</span><br><span class="line">        Object[] array;</span><br><span class="line">  			<span class="comment">//先对局部变量赋值，如果当前size大于等于array的长度，进入扩容，传入array、cap变量</span></span><br><span class="line">        <span class="keyword">while</span> ((n = size) &gt;= (cap = (array = queue).length))</span><br><span class="line">            tryGrow(array, cap);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">            <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">              	<span class="comment">//使用最小堆的“上沉操作”，将元素插入到正确的位置</span></span><br><span class="line">                siftUpComparable(n, e, array);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                siftUpUsingComparator(n, e, array, cmp);</span><br><span class="line">            size = n + <span class="number">1</span>;</span><br><span class="line">          	<span class="comment">//唤醒take操作处于等待队列的线程</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>看下tryGrow扩容操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryGrow</span><span class="params">(Object[] array, <span class="keyword">int</span> oldCap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//因为offer操作中先加了锁，扩容时没必要上锁，所以释放锁</span></span><br><span class="line">  	lock.unlock(); <span class="comment">// must release and then re-acquire main lock</span></span><br><span class="line">    <span class="comment">//定义局部变量新的数组</span></span><br><span class="line">  	Object[] newArray = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//使用CAS操作，只有一个线程能成功进行扩容</span></span><br><span class="line">  	<span class="keyword">if</span> (allocationSpinLock == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, allocationSpinLockOffset,</span><br><span class="line">                                 <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">//如果旧容量小于64，新容量扩增一倍</span></span><br><span class="line">          	<span class="comment">//如果旧容量大于64，新容量扩增1/2</span></span><br><span class="line">            <span class="keyword">int</span> newCap = oldCap + ((oldCap &lt; <span class="number">64</span>) ?</span><br><span class="line">                                   (oldCap + <span class="number">2</span>) : <span class="comment">// grow faster if small</span></span><br><span class="line">                                   (oldCap &gt;&gt; <span class="number">1</span>));</span><br><span class="line">            <span class="comment">//新容量如果大于2的31次方-9，判断如果旧容量+1大于这个值，抛出异常</span></span><br><span class="line">          	<span class="comment">//否则新容量为这个值</span></span><br><span class="line">          	<span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;    <span class="comment">// possible overflow</span></span><br><span class="line">                <span class="keyword">int</span> minCap = oldCap + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (minCap &lt; <span class="number">0</span> || minCap &gt; MAX_ARRAY_SIZE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">                newCap = MAX_ARRAY_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//注意queue==array，如果扩容过程中数组被修改了，被其它线程成功扩容，本线程扩容就失败了</span></span><br><span class="line">            <span class="keyword">if</span> (newCap &gt; oldCap &amp;&amp; queue == array)</span><br><span class="line">                newArray = <span class="keyword">new</span> Object[newCap];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//CAS变量重置为0</span></span><br><span class="line">            allocationSpinLock = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//如果扩容失败，该线程主动退出CPU调度</span></span><br><span class="line">    <span class="keyword">if</span> (newArray == <span class="keyword">null</span>) <span class="comment">// back off if another thread is allocating</span></span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="comment">//重新获取lock锁</span></span><br><span class="line">  	lock.lock();</span><br><span class="line">  	<span class="comment">//如果成功扩容，复制数据到新的数组</span></span><br><span class="line">    <span class="keyword">if</span> (newArray != <span class="keyword">null</span> &amp;&amp; queue == array) &#123;</span><br><span class="line">        queue = newArray;</span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, oldCap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>take操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//获取lock锁，可响应中断</span></span><br><span class="line">  	lock.lockInterruptibly();</span><br><span class="line">    E result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//如果队列中元素为空，当前线程进入等待队列</span></span><br><span class="line">        <span class="keyword">while</span> ( (result = dequeue()) == <span class="keyword">null</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素出队</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] array = queue;</span><br><span class="line">            <span class="comment">//返回队列头部元素</span></span><br><span class="line">          	E result = (E) array[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//将队尾元素移至队首，然后队尾置空</span></span><br><span class="line">          	E x = (E) array[n];</span><br><span class="line">            array[n] = <span class="keyword">null</span>;</span><br><span class="line">            Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">            <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">              	<span class="comment">//最小堆的“下沉操作”，将队尾元素下沉到正确的位置</span></span><br><span class="line">                siftDownComparable(<span class="number">0</span>, x, array, n);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                siftDownUsingComparator(<span class="number">0</span>, x, array, n, cmp);</span><br><span class="line">            size = n;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h6><p>DelayQueue阻塞队列是基于PriorityQueue优先级队列形成的，元素的数量没有限制，所以是无边界的。其次，DelayQueue队列的元素必须实现Delayed接口。延时越小的元素放在队列前面，take操作每次也从队首取出元素。</p>
<ul>
<li>字段属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">		<span class="comment">//操作需要获取的lock锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//真正保存元素的优先级队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line">    <span class="comment">//leader线程是当前进行take操作的线程，如果队首元素延时没有到，该线程成为leader线程</span></span><br><span class="line">    <span class="comment">//等该线程take操作完后，lead为null，其它的take操作线程竞争成为新的leader线程</span></span><br><span class="line"> 		<span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//用来等待不能进行take操作的线程，可能元素延时未到或者当前线程不是leader线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>PriorityQueue的元素放置顺序是由其实现的compareTo方法实现的，排序越小的元素放到队列前面，所以如果排序方法不对，会使延时过期时间长的元素比过期时间短的元素排到更前面，延时低的元素无法出队。    </p>
</blockquote>
<ul>
<li><p>构造器</p>
<p>public DelayQueue(){}、 public DelayQueue(Collection&lt;? extends E&gt; c){…}</p>
</li>
</ul>
<p>构造器只有两种，没有赋值操作</p>
<ul>
<li>take操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//获取lock锁，可响应中断</span></span><br><span class="line">  	lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//循环处理</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          	<span class="comment">//获取队列首元素</span></span><br><span class="line">            E first = q.peek();</span><br><span class="line">          	<span class="comment">//如果队列还没有元素被添加，当前线程释放锁，进入等待队列</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">//getDelay(NANOSECONDS）判断当前时间元素是否过期</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">              	<span class="comment">//如果过期，则进行poll()操作，然后返回队首元素</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">              	<span class="comment">//等待时候，first设为null</span></span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="comment">//如果leader线程不为空，则当前线程释放锁，进入等待队列</span></span><br><span class="line">              	<span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//如果leader线程为空，说明没有take操作的线程竞争称为leader线程，当前线程</span></span><br><span class="line">                  <span class="comment">//成为leader线程</span></span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                      	<span class="comment">//等待剩余的过期时间，当前leader线程释放锁，进入等待队列</span></span><br><span class="line">                      	<span class="comment">//直到当前线程再次获取到锁的过程中，其它线程获得了锁，但是不是leader</span></span><br><span class="line">                      	<span class="comment">//线程，也还会释放锁，进入等待队列</span></span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                      	<span class="comment">//当前leader线程成功获取锁后，leader线程设置为null</span></span><br><span class="line">                      	<span class="comment">//进入下一个循环，返回队首元素</span></span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      	<span class="comment">//当前线程成功进行完take操作后，如果队列还有元素，唤醒等待队列中的线程进行take操作</span></span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">      	<span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>put操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//获取lock锁</span></span><br><span class="line">  	lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//调用的是priotityqueue的offer()方法</span></span><br><span class="line">        q.offer(e);</span><br><span class="line">      	<span class="comment">//如果插入的元素刚好位于队首，将leader线程置为null，唤醒等待队列中的线程，进行take操作</span></span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            available.signal();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>先介绍以上四种常见的阻塞队列，主要阻塞队列的种类和各自的特点比较多杂，剩余的三种之后再介绍吧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/max.github.io/2020/04/06/netty集群的一次实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/max.github.io/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/max.github.io/2020/04/06/netty集群的一次实践/" itemprop="url">netty集群的一次实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-06T13:03:30+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/max.github.io/categories/netty/" itemprop="url" rel="index">
                    <span itemprop="name">netty</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="netty集群的一次实践"><a href="#netty集群的一次实践" class="headerlink" title="netty集群的一次实践"></a>netty集群的一次实践</h4><h6 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h6><p>我们使用netty时，一般只设计一个服务端节点。这样也没什么问题，单机环境下netty最大可支撑1w左右客户端长连接，但是如果有更多的客户端连接需求，单机就满足不了了。可以采用netty集群的方案解决，集群的意思就是多个服务器部署相同的netty服务，增大客户端连接数量。那怎么管理这些服务端节点，怎么让客户端均衡地获得服务器资源，可以使用zookeeper解决。</p>
<blockquote>
<p>zookeeper在dubbo中用来管理注册服务和提供服务。那么在这里我们也需要实现服务注册、提供、发现，还要解决一个负载均衡的问题。</p>
</blockquote>
<h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><p>1、服务注册</p>
<p>netty的服务注册，就是netty启动时将服务器的ip、port作为一个ZNode注册到zookeeper中，ZNode就是zookeeper中数据的最小单元。每个节点可以存储数据，也可以挂载子节点，构成一个树。如下图所示：</p>
<p><img src="/max.github.io/2020/04/06/netty集群的一次实践/first.png" alt="first"></p>
<p>zookeeper访问每个节点 是按照路径访问，类似Unix的文件系统。</p>
<p>注册生成的节点有四种类型</p>
<blockquote>
<p>持久节点PRESISTENT</p>
</blockquote>
<p>持久节点生成后，就会一直存在zookeeper服务器中，直到有删除操作主动删除。</p>
<blockquote>
<p>临时节点EPHEMERAL</p>
</blockquote>
<p>临时节点会在客户端和zookeeper服务器会话断开时自动删除，其中zookeeper规定了不能基于临时节点创建子节点，只能作为叶子节点。</p>
<p>这里要注意一个问题：如果消费者不断地去连接之前订阅的服务节点的过程中，这个节点如果是持久节点，当提供这个服务节点的提供者因为宕机对外不能提供服务，但是zookeeper并不会删除这个节点，导致仍有消费者不断连接这个服务节点，就会出现错误。所以这种情况下作为临时节点，如果消费者订阅的节点出现异常，就会通知消费者，进而进行其它处理。</p>
<blockquote>
<p>持久顺序节点PERSISTENT_SEQUENTIAL</p>
</blockquote>
<p>在持久节点基础上，会额外为每一个父节点的第一级子节点维护创建顺序。</p>
<blockquote>
<p>临时顺序节点EPHEMERAL_SEQUENTIAL</p>
</blockquote>
<p>在临时节点基础上，也增加了顺序的特性。</p>
<p>先创建一个根节点，然后将ip、port作为一个子节点，根节点类型是持久节点，子节点类型是临时节点。</p>
<p>使用Java的ZKClient类实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//创建根节点</span><br><span class="line">public void createRootNode()&#123;</span><br><span class="line">        boolean exists = zkClient.exists(&quot;/root&quot;);</span><br><span class="line">        if (exists)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;	</span><br><span class="line"></span><br><span class="line">        //创建 root</span><br><span class="line">        zkClient.createPersistent(&quot;/root&quot;) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建子节点</span><br><span class="line"> public void createNode(String path) &#123;</span><br><span class="line">        zkClient.createEphemeral(path);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public void RegisterZK()&#123;</span><br><span class="line">   	createRootNode();</span><br><span class="line">   	//本机ip</span><br><span class="line">   	String ip = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">   	String path =&quot;/root&quot;+ +&quot;/&quot;+ip+&quot;:&quot;+&quot;8088&quot;;</span><br><span class="line">   	</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>2、服务提供</p>
<p>客户端每次怎么发现服务器的节点列表，怎么把注册的服务提供客户端。</p>
<ul>
<li>每次都到zookeeper中查询，显然这种效率太低。</li>
<li>本地使用一个缓存列表保存zookeeper的可用服务节点，并且zookeeper的节点发生变更，本地的缓存列表也需要变更。</li>
</ul>
<p>使用缓存列表的方式相较更合理些。</p>
<p>使用<code>com.google.common.cache</code>包的LoadingCache类作为缓存列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public CacheUtil&#123;</span><br><span class="line">		</span><br><span class="line">		 @Autowired</span><br><span class="line">	   private LoadingCache&lt;String, String&gt; cache;</span><br><span class="line">  	 	</span><br><span class="line">  	 public void addCache(String key) &#123;</span><br><span class="line">        cache.put(key, key);</span><br><span class="line">     &#125;</span><br><span class="line">    	</span><br><span class="line">     //更新缓存时，先删除再增加 </span><br><span class="line">     public void updateCache(List&lt;String&gt; nodeList) &#123;</span><br><span class="line">        cache.invalidateAll();</span><br><span class="line">        for (String node : nodeList) &#123;</span><br><span class="line">            addCache(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //获取所有节点</span><br><span class="line">		public List&lt;String&gt; getAll() &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">			 if (cache.size() == 0) &#123;</span><br><span class="line">            List&lt;String&gt; allNode = zkClient.getChildren(&quot;/root&quot;);</span><br><span class="line">            for (String node : allNode) &#123;</span><br><span class="line">                addCache(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (Map.Entry&lt;String, String&gt; entry : cache.asMap().entrySet()) &#123;</span><br><span class="line">            list.add(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、服务订阅</p>
<p>上面使用一个缓存列表来保存zookeeper中注册的可用服务节点，并且注册的节点的变更也会同步到缓存列表中。怎么保证同步的？或者说客户端怎么订阅zookeeper的服务？</p>
<p>zookeeper提供了一个Watcher机制，实现当客户端订阅的服务状态发生变化，zookeeper会自动通知客户端。</p>
<p><img src="/max.github.io/2020/04/06/netty集群的一次实践/two.png" alt="two"></p>
<p>Watcher机制如上图所示</p>
<ul>
<li>客户端向zookeeper注册Watcher</li>
<li>Watcher对象会存储在客户端的WatchManager中</li>
<li>当zookeeper触发Watcher事件后，会向 客户端发送通知，客户端从WatcheManager中取出对应的Watcher对象来执行回调逻辑</li>
</ul>
<blockquote>
<p>这里需要注意的是：当节点发生变更时，zookeeper的watcher只会通知客户端数据节点发生变更，而节点的原始数据和变更后的数据是无法从通知事件中得到的，需要客户端重新主动从zookeeper中获取。</p>
</blockquote>
<p>其实可以看出，使用向zookeeper订阅服务，尽管客户端想获取可用服务节点列表时，不用每次都向zookeeper查询，但是如果数据节点发生变更时，还会再重新请求zookeeper的。如果没有发生变更，那就直接可以使用缓存列表的节点。</p>
<p>Java使用ZKClient的<code>subscribeChildChanges</code>类订阅指定数据节点。可以订阅根节点“/root”，那么每当子节点数据发生变更时，说明netty服务器数量发生变更，就可以返回客户端最新的服务器节点列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//监听zookeeper的“/root”根节点</span><br><span class="line">public void subscribeEvent(String path) &#123;</span><br><span class="line">        zkClient.subscribeChildChanges(path, new IZkChildListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handleChildChange(String parentPath, List&lt;String&gt; currentChilds) throws Exception &#123;</span><br><span class="line">								</span><br><span class="line">                //更新所有缓存，先删除再新增</span><br><span class="line">                serverCache.updateCache(currentChilds) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>   4、负载均衡</p>
<p>客户端现在每次连接时，可以直接从LoadingCache中获取。问题是怎么能均衡地连接列表的服务器节点。</p>
<p>先从最简单解决方法开始，使用“取模“，每次客户端连接，获取LoadingCache的服务器列表时，计数器值+1，然后对列表长度取模得到索引，然后返回该索引对应的服务器节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//负载均衡第一种实现</span><br><span class="line"></span><br><span class="line">//使用原子计数器</span><br><span class="line">private AtomicLong index = new AtomicLong();</span><br><span class="line">public String balance() &#123;</span><br><span class="line">				//CacheUtil的getAll方法</span><br><span class="line">        List&lt;String&gt; all = getAll();</span><br><span class="line">        if (all.size() == 0) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;CIM 服务器可用服务列表为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Long position = index.incrementAndGet() % all.size();</span><br><span class="line">        if (position &lt; 0) &#123;</span><br><span class="line">            position = 0L;</span><br><span class="line">        &#125;</span><br><span class="line">        return all.get(position.intValue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 本质上其实是”轮询“，当客户端连接数量少时，服务器的负载比较均衡，性能也比较快。但是当客户端连接千万级并发量时，取模过程毕竟有线程的竞争，性能会有影响。并且，服务器的上线下线，也会影响负载均衡。</p>
<p>这是在单机实现的负载均衡的服务，如果在分布式集群中，实现负载均衡的服务的机器是集群的话，由于请求是不均匀的，请求负载均衡的服务也是不均衡的，这样就不能保证服务器列表的负载均衡了。</p>
<blockquote>
<p>在解决分布式集群的负载均衡上，可以使用一致性Hash算法。</p>
</blockquote>
<p>一致性hash算法中，根据算法的值构成一个hash环。每次有一个请求绑定的key，对key进行一次hash运算，同样对每个服务器ip或主机名也会做一次hash运算，然后将两种hash值映射到hash环中。</p>
<p><img src="/max.github.io/2020/04/06/netty集群的一次实践/three.png" alt="three"></p>
<ul>
<li>请求经过hash运算后，然后映射到对应的位置，那么对应负载的服务器节点就是顺时针的第一个节点。</li>
<li>当有服务器节点删除时，之前对应的请求会负载到该节点按照顺时针的下一个节点。</li>
<li>新增节点也是一样。</li>
</ul>
<p>这里存在一个问题，可能由于删除的节点负载了大量的请求，这样导致下一个节点负载更多的请求，会造成一定的负载不均衡。</p>
<p>引入”虚拟节点“：对同一个服务器进行多次hash，得到的hash值分布在hash环中，这些节点就称为”虚拟节点”。一般可以在服务器ip后面添加编号，然后进行hash得到虚拟节点。</p>
<p><img src="/max.github.io/2020/04/06/netty集群的一次实践/four.png" alt="four"></p>
<p>这样可以解决当有节点删除时，减少大量请求负载在某个节点上面。当然，最终请求如果映射到某个虚拟节点上，还是需要将虚拟节点转为真实的节点连接。</p>
<blockquote>
<p>Java实现一致性hash算法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">public class ConsistentHashingBalance &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 集群地址列表</span><br><span class="line">     */</span><br><span class="line">    private static String[] groups = &#123;</span><br><span class="line">        &quot;127.0.0.1:8081&quot;, &quot;127.0.0.1:8082&quot;, &quot;127.0.0.1:8083&quot;,</span><br><span class="line">        &quot;127.0.0.1:8084&quot;, &quot;127.0.0.1:8085&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 真实集群列表</span><br><span class="line">     */</span><br><span class="line">    private static List&lt;String&gt; realGroups = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 虚拟节点映射关系</span><br><span class="line">     */</span><br><span class="line">    private static SortedMap&lt;Integer, String&gt; virtualNodes = new TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		//虚拟节点数量</span><br><span class="line">    private static final int VIRTUAL_NODE_NUM = 1000;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        // 先添加真实节点列表</span><br><span class="line">        realGroups.addAll(Arrays.asList(groups));</span><br><span class="line"></span><br><span class="line">        // 将虚拟节点映射到Hash环上</span><br><span class="line">        for (String realGroup: realGroups) &#123;</span><br><span class="line">            for (int i = 0; i &lt; VIRTUAL_NODE_NUM; i++) &#123;</span><br><span class="line">                String virtualNodeName = getVirtualNodeName(realGroup, i);</span><br><span class="line">                int hash = HashUtil.getHash(virtualNodeName);</span><br><span class="line">                System.out.println(&quot;[&quot; + virtualNodeName + &quot;] launched @ &quot; + hash);</span><br><span class="line">               	//放到hash环中</span><br><span class="line">                virtualNodes.put(hash, virtualNodeName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	//通过在真实ip后面加“&amp;&amp;VN&quot;+数字得到虚拟节点ip</span><br><span class="line">    private static String getVirtualNodeName(String realName, int num) &#123;</span><br><span class="line">        return realName + &quot;&amp;&amp;VN&quot; + String.valueOf(num);</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">	//得到虚拟节点对应的真实ip</span><br><span class="line">    private static String getRealNodeName(String virtualName) &#123;</span><br><span class="line">        return virtualName.split(&quot;&amp;&amp;&quot;)[0];</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">		//负载均衡得到服务器ip</span><br><span class="line">    private static String getServer(String key) &#123;</span><br><span class="line">        int hash = HashUtil.getHash(key);</span><br><span class="line">        // 只取出所有大于该hash值的部分而不必遍历整个Tree</span><br><span class="line">        SortedMap&lt;Integer, String&gt; subMap = virtualNodes.tailMap(hash);</span><br><span class="line">        String virtualNodeName;</span><br><span class="line">        if (subMap == null || subMap.isEmpty()) &#123;</span><br><span class="line">            // hash值在最尾部，应该映射到第一个group上</span><br><span class="line">            virtualNodeName = virtualNodes.get(virtualNodes.firstKey());</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            virtualNodeName = subMap.get(subMap.firstKey());</span><br><span class="line">        &#125;</span><br><span class="line">        return getRealNodeName(virtualNodeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 生成随机数进行测试</span><br><span class="line">        Map&lt;String, Integer&gt; resMap = new HashMap&lt;&gt;();</span><br><span class="line">				//一百万个测试连接</span><br><span class="line">        for (int i = 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">            Integer widgetId = i;</span><br><span class="line">            String group = getServer(widgetId.toString());</span><br><span class="line">            if (resMap.containsKey(group)) &#123;</span><br><span class="line">                resMap.put(group, resMap.get(group) + 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resMap.put(group, 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resMap.forEach(</span><br><span class="line">            (k, v) -&gt; &#123;</span><br><span class="line">                System.out.println(&quot;group &quot; + k + &quot;: &quot; + v + &quot;(&quot; + v/10000.0D +&quot;%)&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/max.github.io/2020/04/06/netty集群的一次实践/five.png" alt="five"></p>
<p>结果如上图所示，负载几乎均衡了。当服务器有新增和删除时，也是比较均衡的，这里就不测试了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/max.github.io/2020/03/29/心跳连接分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/max.github.io/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/max.github.io/2020/03/29/心跳连接分析/" itemprop="url">心跳连接分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-29T21:42:13+08:00">
                2020-03-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/max.github.io/categories/netty/" itemprop="url" rel="index">
                    <span itemprop="name">netty</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h5><p>主要针对tcp的长连接，客户端和服务端某一方可能会突然断开连接，为了防止断线造成传输的影响，服务端客户端会每隔一定时间发送tcp数据包，检查连接是否正常，这就是心跳检验机制。</p>
<blockquote>
<p>tcp心跳包还有一个作用，一个连接长时间不用，防火墙或路由器就会断开连接。</p>
</blockquote>
<h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><p><strong>IdleStateHandler</strong> </p>
<p>这个类是继承于ChannelDuplexHandler，继承ChannelInboundHandlerAdapter入站类，和实现了 ChannelOutboundHandler出站类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public IdleStateHandler(long readerIdleTime, long writerIdleTime, long allIdleTime, TimeUnit unit)</span><br></pre></td></tr></table></figure>

<p>构造方法有四个重要的参数，<code>readerIdleTime</code>指服务端多久没读就发送心跳包，<code>writerIdleTime</code>指服务端多久没写就发送心跳包，<code>allIdleTime</code>指服务端多久没读写就发送心跳包，<code>TimeUnitunit</code>指时间的单位。</p>
<p>首先，在服务端Bootstrap的childHandler方法设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                 ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                 pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>, TimeUnit.SECONDS));</span><br><span class="line">                 <span class="comment">//当IdleStateEvent触发后，会由pipeline下一个handler处理事件</span></span><br><span class="line">                 pipeline.addLast(<span class="string">"heartbearhandler"</span>,<span class="keyword">new</span> HeartBeatHandler());</span><br><span class="line">            &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<p>然后，创建HeartBeatHandler自定义handler处理器类，还要实现  userEventTriggered(ChannelHandlerContext ctx, Object evt)方法，<br>event状态有三种，READER_IDLE读超时、WRITER_IDLE写超时、ALL_IDLE读\写超时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent)&#123;</span><br><span class="line">            IdleStateEvent event =(IdleStateEvent) evt;</span><br><span class="line">            String eventType=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (event.state())&#123;</span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                    eventType=<span class="string">"读空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    eventType=<span class="string">"写空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                    eventType=<span class="string">"读写空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress()+<span class="string">"---超时事件----"</span>+eventType+System.currentTimeMillis());</span><br><span class="line">            System.out.println(<span class="string">"服务器做相应处理------"</span>);</span><br><span class="line">            <span class="keyword">if</span>(eventType==<span class="keyword">null</span>)&#123;</span><br><span class="line">                ctx.channel().close();</span><br><span class="line">            &#125;</span><br><span class="line"> &#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><p>在childHandler()方法中，当服务端和客户端连接时，生成NioSocketChannel对象，然后在通道的pipeline中加入了IdleStateHandler处理器对象，自定义的HeartBeatHandler处理器对象。</p>
<blockquote>
<p>看下IdleStateHandler类内部</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public IdleStateHandler(boolean observeOutput, long readerIdleTime, long writerIdleTime, long allIdleTime, TimeUnit unit) &#123;</span><br><span class="line">				//创建一个异步通道监听器对象ChannelFutureListner，重写operationComplete方法</span><br><span class="line">        this.writeListener = new ChannelFutureListener() &#123;</span><br><span class="line">         public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">           //赋值lastWriter属性，值为当前系统时间</span><br><span class="line">            IdleStateHandler.this.lastWriteTime = IdleStateHandler.this.ticksInNanos();</span><br><span class="line">           //赋值firstWriterIdleEvent(首次写超时事件)、firstAllIdleEvent(首次读写超时事件)为true</span><br><span class="line">           IdleStateHandler.this.firstWriterIdleEvent=</span><br><span class="line">            	   IdleStateHandler.this.firstAllIdleEvent = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //赋值firstReaderIdleEvent首次读超时事件为true</span><br><span class="line">        this.firstReaderIdleEvent = true;</span><br><span class="line">        this.firstWriterIdleEvent = true;</span><br><span class="line">        this.firstAllIdleEvent = true;</span><br><span class="line">        if (unit == null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;unit&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        		//赋值出站方法超时标志属性，默认为flase</span><br><span class="line">        		//这个属性，主要是检测当发生写超时事件时，看是否是出站方法导致的超时</span><br><span class="line">            this.observeOutput = observeOutput;</span><br><span class="line">            //依次赋值读超时属性、写超时属性、读写超时属性</span><br><span class="line">            if (readerIdleTime &lt;= 0L) &#123;</span><br><span class="line">                this.readerIdleTimeNanos = 0L;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.readerIdleTimeNanos = Math.max(unit.toNanos(readerIdleTime), MIN_TIMEOUT_NANOS);</span><br><span class="line">            &#125;</span><br><span class="line">            if (writerIdleTime &lt;= 0L) &#123;</span><br><span class="line">                this.writerIdleTimeNanos = 0L;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.writerIdleTimeNanos = Math.max(unit.toNanos(writerIdleTime), MIN_TIMEOUT_NANOS);</span><br><span class="line">            &#125;</span><br><span class="line">            if (allIdleTime &lt;= 0L) &#123;</span><br><span class="line">                this.allIdleTimeNanos = 0L;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.allIdleTimeNanos = Math.max(unit.toNanos(allIdleTime), MIN_TIMEOUT_NANOS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再来看一个方法handlerAdded</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        if (ctx.channel().isActive() &amp;&amp; ctx.channel().isRegistered()) &#123;</span><br><span class="line">            this.initialize(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是最高级ChannelHandler接口的方法，字面上看就是当把handler对象加入到pipeline中时执行的，看下源码。</p>
<p>追朔到最开始应该是客户端连接通道对象NioSocketChannel生成后，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.childGroup.register(child).addListener(new ChannelFutureListener() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>将NioSocketChannel注册到childGroup的一个NioEventLoop线程中，register内部方法执行时，会将NioSocketChannel的childHandler中的ChannelHandler处理器使用addLast()方法加入到pipeline中，其中还会执行this.callHandlerAdded0(newCtx)方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) &#123;</span><br><span class="line">    AbstractChannelHandlerContext newCtx;</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line">        newCtx = this.newContext(group, this.filterName(name, handler), handler);</span><br><span class="line">        //这个就是将handler包装成ChannelHandlerContext，再添加到pipeline中</span><br><span class="line">        this.addLast0(newCtx);</span><br><span class="line">        if (!this.registered) &#123;</span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            this.callHandlerCallbackLater(newCtx, true);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EventExecutor executor = newCtx.executor();</span><br><span class="line">        if (!executor.inEventLoop()) &#123;</span><br><span class="line">            this.callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		//还会执行这个方法</span><br><span class="line">    this.callHandlerAdded0(newCtx);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行内部方法到这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final void callHandlerAdded() throws Exception &#123;</span><br><span class="line">    if (this.setAddComplete()) &#123;</span><br><span class="line">    		//当前handler就是 IdleStateHandler，执行其中的handlerAdded方法</span><br><span class="line">        this.handler().handlerAdded(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>转了一圈，回到了handlerAdded方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">    if (ctx.channel().isActive() &amp;&amp; ctx.channel().isRegistered()) &#123;</span><br><span class="line">        this.initialize(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看initialize方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void initialize(ChannelHandlerContext ctx) &#123;</span><br><span class="line">    switch(this.state) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">    case 2:</span><br><span class="line">        return;</span><br><span class="line">    //刚开始state值为0，所以会执行default</span><br><span class="line">    default:</span><br><span class="line">        this.state = 1;</span><br><span class="line">        //检查出站超时带来的影响</span><br><span class="line">        this.initOutputChanged(ctx);</span><br><span class="line">        //重新赋值lastReadTime、lastWriteTime为当前时间</span><br><span class="line">        this.lastReadTime = this.lastWriteTime = this.ticksInNanos();</span><br><span class="line">        //这里面使用了schedule线程方法，传入IdleStateHandler的task方法，返回的是一个线程异步执行的         //结果</span><br><span class="line">        if (this.readerIdleTimeNanos &gt; 0L) &#123;</span><br><span class="line">            this.readerIdleTimeout = this.schedule(ctx, new IdleStateHandler.ReaderIdleTimeoutTask(ctx), this.readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.writerIdleTimeNanos &gt; 0L) &#123;</span><br><span class="line">            this.writerIdleTimeout = this.schedule(ctx, new IdleStateHandler.WriterIdleTimeoutTask(ctx), this.writerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.allIdleTimeNanos &gt; 0L) &#123;</span><br><span class="line">            this.allIdleTimeout = this.schedule(ctx, new IdleStateHandler.AllIdleTimeoutTask(ctx), this.allIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下IdleStateHandler的内部抽象类AbstractIdleTask</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private abstract static class AbstractIdleTask implements Runnable &#123;</span><br><span class="line">    private final ChannelHandlerContext ctx;</span><br><span class="line"></span><br><span class="line">    AbstractIdleTask(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        //绑定属性IdleStateHandlerContext实例</span><br><span class="line">        this.ctx = ctx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (this.ctx.channel().isOpen()) &#123;</span><br><span class="line">            //run方法内部要实现这个抽象类的run方法执行</span><br><span class="line">            this.run(this.ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    protected abstract void run(ChannelHandlerContext var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这个<code>public void run(){}</code>方法就是模板方法设计模式的模板方法，抽象类中模板方法规定了执行逻辑，但其中的抽象方法可以由子类实现。</p>
<p>就主要看下AbstractIdleTask子类ReaderIdleTimeoutTask</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private final class ReaderIdleTimeoutTask extends IdleStateHandler.AbstractIdleTask &#123;</span><br><span class="line">    ReaderIdleTimeoutTask(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        super(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">		//重写了run方法</span><br><span class="line">    protected void run(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        //获得读超时属性，我传入的参数是2s</span><br><span class="line">        long nextDelay = IdleStateHandler.this.readerIdleTimeNanos;</span><br><span class="line">        if (!IdleStateHandler.this.reading) &#123;</span><br><span class="line">        	  // 重新计算nextDelay，当前系统时间减去上一次读超时的时间</span><br><span class="line">            nextDelay -= IdleStateHandler.this.ticksInNanos() - IdleStateHandler.this.lastReadTime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (nextDelay &lt;= 0L) &#123;</span><br><span class="line">            IdleStateHandler.this.readerIdleTimeout = IdleStateHandler.this.schedule(ctx, this, IdleStateHandler.this.readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">            boolean first = IdleStateHandler.this.firstReaderIdleEvent;</span><br><span class="line">            IdleStateHandler.this.firstReaderIdleEvent = false;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                IdleStateEvent event = IdleStateHandler.this.newIdleStateEvent(IdleState.READER_IDLE, first);</span><br><span class="line">                IdleStateHandler.this.channelIdle(ctx, event);</span><br><span class="line">            &#125; catch (Throwable var6) &#123;</span><br><span class="line">                ctx.fireExceptionCaught(var6);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            IdleStateHandler.this.readerIdleTimeout = IdleStateHandler.this.schedule(ctx, this, nextDelay, TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面调用方法IdleStateHandler.this.schedule(ctx, this, IdleStateHandler.this.readerIdleTimeNanos, TimeUnit.NANOSECONDS)</p>
<p>this就是当前 ReaderIdleTimeoutTask对象，最后括号内部封装成ScheduledFutureTask对象，this.schedule方法会将这个task加入到scheduledTaskQueue任务队列，由ThreadPerTaskExecutor类执行这个任务。</p>
<p>这个方法返回的就是ScheduledFutureTask异步对象。</p>
<blockquote>
<p>执行任务过程中，直到当前时间使发生读超时，接着执行方法IdleStateHandler.this.newIdleStateEvent(IdleState.READER_IDLE, first)</p>
</blockquote>
<p>然后返回IdleStateEvent对象，即读超时事件对象。</p>
<p>再执行 IdleStateHandler.this.channelIdle(ctx, event)，将读超时事件传进去，最终执行内部方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void invokeUserEventTriggered(Object event) &#123;</span><br><span class="line">    if (this.invokeHandler()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ((ChannelInboundHandler)this.handler()).userEventTriggered(this, event);</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            this.notifyHandlerException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.fireUserEventTriggered(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this.handler()返回的就是我定义的HeartBeatHandler处理器对象，执行重写的userEventTriggered方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;</span><br><span class="line">    if(evt instanceof IdleStateEvent)&#123;</span><br><span class="line">        IdleStateEvent event =(IdleStateEvent) evt;</span><br><span class="line">        String eventType=null;</span><br><span class="line">        switch (event.state())&#123;</span><br><span class="line">            case READER_IDLE:</span><br><span class="line">                eventType=&quot;读空闲&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case WRITER_IDLE:</span><br><span class="line">                eventType=&quot;写空闲&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case ALL_IDLE:</span><br><span class="line">                eventType=&quot;读写空闲&quot;;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这就可以根据发生什么超时事件，进行一些业务处理，比如通过ctx向客户端socket通道写数据并监听，如果没有回复就可以关闭通道等。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/max.github.io/2020/03/22/自定义channelhandler处理器执行客户端请求的过程分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/max.github.io/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/max.github.io/2020/03/22/自定义channelhandler处理器执行客户端请求的过程分析/" itemprop="url">自定义channelhandler处理器执行客户端请求的过程分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-22T21:27:28+08:00">
                2020-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/max.github.io/categories/netty/" itemprop="url" rel="index">
                    <span itemprop="name">netty</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="客户端请求在pipeline中handler处理器的执行过程分析"><a href="#客户端请求在pipeline中handler处理器的执行过程分析" class="headerlink" title="客户端请求在pipeline中handler处理器的执行过程分析"></a>客户端请求在pipeline中handler处理器的执行过程分析</h5><h6 id="1、回顾下服务器接收请求的过程"><a href="#1、回顾下服务器接收请求的过程" class="headerlink" title="1、回顾下服务器接收请求的过程"></a>1、回顾下服务器接收请求的过程</h6><ul>
<li><p>NioServerSocketChannel注册到一个NioEventLoop线程中，会监听这个通道，如果监听到事件发生，在<code>processSelectedKeys()</code>方法中处理。</p>
</li>
<li><p>这个方法内部判断，如果是Accept事件，调用 <code>unsafe.read()</code>方法。其中， <code>doReadMessages(List&lt;Object&gt; buf)</code> 方法使用<code>SocketUtils.accept()</code>生成客户端连接通道对象SoketChannel，添加到buf集合中。</p>
</li>
<li><p><code>unfase.read()</code>接着遍历buf集合， 将每个客户端连接通道对象传NioServerSocketChannel的pipeline对象中，执行方法<code>pipeline.fireChannelRead(this.readBuf.get(i))</code>。</p>
</li>
<li><p><code>fireChannelRead()</code>方法中。之前在netty启动过程已经将NioServerSocketChannel的pipeline，设置ChannelHandlerContext双向链表，包含的节点是：head内部类头节点——》LoggingHandler处理器构成的一个节点——》ServerBootstrap.ServerBootstrapAcceptor处理器构成的一个节点——》tail内部类尾节点。</p>
<p><code>fireChannelRead()</code>方法内部调用<code>invokeChannelRead(this.findContextInbound(32), msg)</code>方法，会不断执行所有的节点<code>channelRead()</code>方法。当执行到ServerBootstrapAcceptor处理器所在的节点，先得到SocketChannel的pipeline对象，将在服务端代码自定义的handler对象通过addLast()方法加到pipeline对象中。这样生成的客户端连接通道对象，pipeline中就构建了channelhandler处理器链。最后还要将SocketChannel对象注册到childgroup中一个NioEventLoop线程，并添加监视器。<code>this.childGroup.register(child).addListener()</code> 。</p>
</li>
<li><p>这节分析的就是客户端连接通道对象，在pipeline中怎么执行我们自定义的channelhandler。</p>
</li>
</ul>
<h6 id="2、NioSocketChannel通道处理事件的过程"><a href="#2、NioSocketChannel通道处理事件的过程" class="headerlink" title="2、NioSocketChannel通道处理事件的过程"></a>2、NioSocketChannel通道处理事件的过程</h6><p>当把NioSocketChannel通道注册到workgroup的eventloop线程，其实和NioServerSocketChannel通道处理客户端事件一样，也会在eventloop线程中监听客户端的事件    </p>
<ul>
<li><p>NioEventLoop中run()方法的<code>this.processSelectedKeys()</code>方法，其内部调用<code>this.processSelectedKeysOptimized()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysOptimized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里selectedKeys大小为一，即一个客户端连接事件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.selectedKeys.size; ++i) &#123;</span><br><span class="line">        SelectionKey k = <span class="keyword">this</span>.selectedKeys.keys[i];</span><br><span class="line">        <span class="keyword">this</span>.selectedKeys.keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//attachment()返回的是NioSocketChannel客户端连接通道对象</span></span><br><span class="line">        Object a = k.attachment();</span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">            <span class="comment">//再调用这个方法</span></span><br><span class="line">            <span class="keyword">this</span>.processSelectedKey(k, (AbstractNioChannel)a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            NioTask&lt;SelectableChannel&gt; task = (NioTask)a;</span><br><span class="line">            processSelectedKey(k, task);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.needsToSelectAgain) &#123;</span><br><span class="line">            <span class="keyword">this</span>.selectedKeys.reset(i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.selectAgain();</span><br><span class="line">            i = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后的逻辑就和NioServerSocketChannel的处理一样，监听到Accept事件，执行unsafe.read()方法，然后依次执行SocketChannel的pipeline中的ChannelHandlerContext的<code>channelRead()</code>方法，比如我们自定义了EchoServerHandler类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span>  <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.write(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完ChannelHandlerContext链的头节点后，就执行EchoServerHandler的节点，channelRead()方法就会执行我们重写的方法。<br>当然，后面还可以依次执行每个节点的channelReadComplete方法。包括出现异常时执行 exceptionCaught    方法。</p>
</li>
</ul>
<h6 id="3、小节"><a href="#3、小节" class="headerlink" title="3、小节"></a>3、小节</h6><p>​其实把NioSocketChannel注册到NioEventLoop线程后，处理客户端的事件和        NioServerSocketChannel处理连接事件一样。需要注意的是：两个通道对象一个是在    bossgroup的线程中注册，一个是在workgroup中线程注册。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/max.github.io/2020/03/09/netty接受客户端请求过程分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/max.github.io/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/max.github.io/2020/03/09/netty接受客户端请求过程分析/" itemprop="url">netty接受客户端请求过程分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-09T18:44:44+08:00">
                2020-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/max.github.io/categories/netty/" itemprop="url" rel="index">
                    <span itemprop="name">netty</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="netty服务器接受请求过程"><a href="#netty服务器接受请求过程" class="headerlink" title="netty服务器接受请求过程"></a>netty服务器接受请求过程</h4><blockquote>
<p>回顾netty的启动过程中，最后是bossgroup的NioEventLoop线程会监听ServerSocketChannel这个通道，如果有事件发生，使用<code>processSelectedKeys()</code> 方法处理事件，最后还要处理消息队列中的所有任务 <code>this.runAllTasks()</code>。</p>
</blockquote>
<p><code>processSelectedKey(SelectionKey k, AbstractNioChannel ch)</code>是<code>processSelectedKeys()</code>内部调用核心方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当服务器在通道上监听到事件就会执行这个方法，当然这个方法是bossgroup的nioEventLoop线程下执行的</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//unsafe是这个类AbstractNioMessageChannel$NioMessageUnsafe的实例</span></span><br><span class="line">    NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">    <span class="keyword">if</span> (!k.isValid()) &#123;</span><br><span class="line">        NioEventLoop eventLoop;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">       		<span class="comment">//获得bossgroup的nioEventLoop</span></span><br><span class="line">            eventLoop = ch.eventLoop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eventLoop == <span class="keyword">this</span> &amp;&amp; eventLoop != <span class="keyword">null</span>) &#123;</span><br><span class="line">            unsafe.close(unsafe.voidPromise());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">//readyOps就是事件类型对应的值</span></span><br><span class="line">            <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; <span class="number">8</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">                ops &amp;= -<span class="number">9</span>;</span><br><span class="line">                k.interestOps(ops);</span><br><span class="line">                unsafe.finishConnect();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                ch.unsafe().forceFlush();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; <span class="number">17</span>) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果是连接Accept事件就会执行unsafe的read方法</span></span><br><span class="line">                unsafe.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException var7) &#123;</span><br><span class="line">            unsafe.close(unsafe.voidPromise());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/max.github.io/2020/03/09/netty接受客户端请求过程分析/netty-2.png" alt="netty-2"></p>
<p>浏览器访问服务器端口，经过debug可以看到readyOps值是16，在SelectionKey这个类中，</p>
<ol>
<li>读事件是 <code>OP_READ = 1 &lt;&lt; 0</code>值为1</li>
<li>写事件是<code>OP_WRITE = 1 &lt;&lt; 2</code>值为4  </li>
<li>连接事件是<code>OP_CONNECT = 1 &lt;&lt; 3</code>值为8</li>
<li>接收事件是<code>OP_ACCEPT = 1 &lt;&lt; 4</code>值为16</li>
</ol>
<blockquote>
<p>然后进入了unsafe.read（）方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> AbstractNioMessageChannel.<span class="keyword">this</span>.eventLoop().inEventLoop();</span><br><span class="line">    ChannelConfig config = AbstractNioMessageChannel.<span class="keyword">this</span>.config();</span><br><span class="line">    <span class="comment">//获得NioServerSocketChannel的pipeline</span></span><br><span class="line">    ChannelPipeline pipeline = AbstractNioMessageChannel.<span class="keyword">this</span>.pipeline();</span><br><span class="line">    Handle allocHandle = AbstractNioMessageChannel.<span class="keyword">this</span>.unsafe().recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line">    <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line">    Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> localRead;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">            	<span class="comment">//AbstractNioMessageChannel.this就是NioServerSocketChannel，调用了doReadMessages</span></span><br><span class="line">            	<span class="comment">//方法，并且传入了一个readBuf参数</span></span><br><span class="line">                localRead = AbstractNioMessageChannel.<span class="keyword">this</span>.doReadMessages(<span class="keyword">this</span>.readBuf);</span><br><span class="line">                <span class="keyword">if</span> (localRead == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (localRead &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    closed = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                allocHandle.incMessagesRead(localRead);</span><br><span class="line">            &#125; <span class="keyword">while</span>(allocHandle.continueReading());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var11) &#123;</span><br><span class="line">            exception = var11;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        localRead = <span class="keyword">this</span>.readBuf.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; localRead; ++i) &#123;</span><br><span class="line">            AbstractNioMessageChannel.<span class="keyword">this</span>.readPending = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//NioServerSocketChannel的pipeline，执行fireChannleRead(),传入了readBuf</span></span><br><span class="line">            pipeline.fireChannelRead(<span class="keyword">this</span>.readBuf.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.readBuf.clear();</span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">            closed = AbstractNioMessageChannel.<span class="keyword">this</span>.closeOnReadError(exception);</span><br><span class="line">            pipeline.fireExceptionCaught(exception);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">            AbstractNioMessageChannel.<span class="keyword">this</span>.inputShutdown = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (AbstractNioMessageChannel.<span class="keyword">this</span>.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.close(<span class="keyword">this</span>.voidPromise());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!AbstractNioMessageChannel.<span class="keyword">this</span>.readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.removeReadOp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重点看下这个方法 localRead = AbstractNioMessageChannel.this.doReadMessages(this.readBuf)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//SocketUtils.accept方法产生了一个客户端连接通道SocketChannel！</span></span><br><span class="line">    SocketChannel ch = SocketUtils.accept(<span class="keyword">this</span>.javaChannel());</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="comment">//this就是NioServerSocketChannel，和SocketChannel封装在一起，添加到list中</span></span><br><span class="line">        	<span class="comment">//list就是最开始的unsafe【AbstractNioMessageChannel$NioMessageUnsafe】实例的readbuf</span></span><br><span class="line">            buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Failed to create a new channel from an accepted socket."</span>, var6);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Failed to close a socket."</span>, var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SocketUtils.accept()返回的不就是我们想要客户端连接通道吗！得到了这个通道，接下来就是处理这个连接事件。处理客户端通道的连接事件在<code>pipeline.fireChannelRead(this.readBuf.get(i))</code>方法中。</p>
<blockquote>
<p>pipeline.fireChannelRead(this.readBuf.get(i))，这个方法，先得到NioServerSocketChannel的pipeline，然后调用fireChannelRead方法，传入readBuf，里面是封装了serversocketchannel和socketchannle的NioSocketChannel（在上面的doReadMessage方法中创建的）</p>
</blockquote>
<p>这个方法里面是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final ChannelPipeline fireChannelRead(Object msg) &#123;</span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelRead(this.head, msg);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invokeChannelRead方法传入了两个参数，this是NioServerSocketChannel的pipeline，之前在netty启动过程中分析了serversocketchannel的pipeline，包含了由ChannelHandlerContext构成的双链表结构，结构是：head内部类头节点——&gt;LoggingHandler处理器构成的一个节点——&gt;ServerBootstrap.ServerBootstrapAcceptor处理器构成的一个节点——&gt;tail内部类尾节点。</p>
<blockquote>
<p>this.head就是pipeline的head节点，msg就是NioSocketChannel。</p>
</blockquote>
<p>再看方法内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokeChannelRead(this.findContextInbound(32), msg)</span><br></pre></td></tr></table></figure>

<p>一直追下去，直到这个方法，this是Head头节点，findContext方法干了什么呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private AbstractChannelHandlerContext findContextInbound(int mask) &#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = this;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        ctx = ctx.next;</span><br><span class="line">    &#125; while((ctx.executionMask &amp; mask) == 0);</span><br><span class="line"></span><br><span class="line">    return ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是next()方法获得下一个节点，下一个节点就是LoggingHandler的节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">    if (this.logger.isEnabled(this.internalLevel)) &#123;</span><br><span class="line">        this.logger.log(this.internalLevel, this.format(ctx, &quot;READ&quot;, msg));</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.fireChannelRead(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到执行完又执行了fireChannelRead方法，又是循环，下一个节点是ServerBootstrap.ServerBootstrapAcc</p>
<p>-eptor处理器构成的节点。这个Handler处理过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">    //得到NioSocketChannel</span><br><span class="line">    final Channel child = (Channel)msg;</span><br><span class="line">    /**</span><br><span class="line">    *向NioSocketChannel的pipeline加入处理器！</span><br><span class="line">    *this是ServerBootstrap的内部类ServerBootstrapAcceptor</span><br><span class="line">    *childHandler就是我们之前实现了ChannelInitializer类，在里面添加了自定义的channelhandler！！</span><br><span class="line">    **/</span><br><span class="line">    child.pipeline().addLast(new ChannelHandler[]&#123;this.childHandler&#125;);</span><br><span class="line">    AbstractBootstrap.setChannelOptions(child, this.childOptions, ServerBootstrap.logger);</span><br><span class="line">    AbstractBootstrap.setAttributes(child, this.childAttrs);</span><br><span class="line">    try &#123;</span><br><span class="line">    	//到这里发现了客户端连接通道是childGroup线程组注册的</span><br><span class="line">        this.childGroup.register(child).addListener(new ChannelFutureListener() &#123;</span><br><span class="line">            public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">                if (!future.isSuccess()) &#123;</span><br><span class="line">                    ServerBootstrap.ServerBootstrapAcceptor.forceClose(child, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; catch (Throwable var5) &#123;</span><br><span class="line">        forceClose(child, var5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>child.pipeline().addLast(new ChannelHandler[]{this.childHandler})，这个方法成功的将我们自定义的handler处理器添加到NioSocketChannel的pipeline中，就能读写客户端发送的数据了！</p>
</blockquote>
<p>还没有完，接着this.childGroup是最开始自定义的workgroup，包含了8个NioEventLoop线程。然后将NioSocketChannel注册到这个workgroup中，使用workgroup线程组执行客户端连接，不就是最开始说的服务器接收到客户端连接后，使用workgroup处理连接吗！当然，还加了一个Listener监听器。</p>
<p>【childgroup.register()的逻辑和启动过程中bossgroup.register(NioServerSocketChannel)逻辑相同，这里就不赘述了。】</p>
<p>至此netty启动过程和接受请求过程粗略地分析了一遍，肯定还有很多细节没分析，等之后再花功夫把细节完善下。后面就是看pipeline管道的handler处理器是怎么依次执行的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/max.github.io/2020/03/01/netty启动过程分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/max.github.io/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/max.github.io/2020/03/01/netty启动过程分析/" itemprop="url">netty启动过程分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-01T19:20:10+08:00">
                2020-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/max.github.io/categories/netty/" itemprop="url" rel="index">
                    <span itemprop="name">netty</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="netty的启动过程"><a href="#netty的启动过程" class="headerlink" title="netty的启动过程"></a>netty的启动过程</h4><ol>
<li><p><strong>创建线程组</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = new NioEventLoopGroup(1);</span><br><span class="line">EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br></pre></td></tr></table></figure>

<p>bossGroup线程组用来监听客户端的连接，workerGroup线程组用来处理客户端连接通道。</p>
<blockquote>
<p>new NioEventLoopGroup()设置断点</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public NioEventLoopGroup() &#123;</span><br><span class="line">    this(0);</span><br><span class="line">&#125;</span><br><span class="line">—— ——&gt;继续into</span><br><span class="line">public NioEventLoopGroup(int nThreads) &#123;</span><br><span class="line">        this(nThreads, (Executor)null);</span><br><span class="line">&#125;</span><br><span class="line">—— ——&gt;</span><br><span class="line">//到这里，又传入了两个参数，线程执行器executor和nio的选择器selector</span><br><span class="line">public NioEventLoopGroup(int nThreads, Executor executor) &#123;</span><br><span class="line">        this(nThreads, executor, SelectorProvider.provider());</span><br><span class="line">&#125;</span><br><span class="line">—— ——&gt;</span><br><span class="line">//重要的参数改变了，如果传入线程数==0，则设为DEFAULT_EVENT_LOOP_THREADS，</span><br><span class="line">  否则线程数就是构造器传入的</span><br><span class="line">//并传给父类MultithreadEventExecutorGroup构造器方法</span><br><span class="line">protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) &#123;</span><br><span class="line">        super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">&#125;</span><br><span class="line">//默认的线程数是cpu数*2</span><br><span class="line">DEFAULT_EVENT_LOOP_THREADS=Math.max(1,SystemPropertyUtil.getInt(&quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors()*2));</span><br><span class="line">—— ——&gt;</span><br><span class="line"> //这个里面的方法才是真正创建线程组的</span><br><span class="line"> protected MultithreadEventExecutorGroup(int nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args)&#123;</span><br><span class="line"> 	...</span><br><span class="line"> 	//给executor赋值，创建ThreadPerTaskExecutor类实例</span><br><span class="line"> 	 if (executor == null) &#123;</span><br><span class="line">          executor = new ThreadPerTaskExecutor(this.newDefaultThreadFactory());</span><br><span class="line">      &#125;</span><br><span class="line">    //创建线程组，EventExecutor是接口Executor的实现类</span><br><span class="line">    this.children = new EventExecutor[nThreads];</span><br><span class="line">    for(int i = 0; i &lt; nThreads; ++i) &#123;</span><br><span class="line">	....</span><br><span class="line">	try&#123;</span><br><span class="line">		//使用new Child()方法，对每个线程赋值</span><br><span class="line">		//new Child()抽象方法，NioEventLoop类重写了，返回NioEventLoop类型</span><br><span class="line">		this.children[i] = this.newChild((Executor)executor, args);</span><br><span class="line">		...</span><br><span class="line">	&#125;catch (Exception var19) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;failed to create a child event loop&quot;, 		var19);</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">                if (var18) &#123;</span><br><span class="line">                      	if (!success) &#123;</span><br><span class="line">                      		//如果某个线程实例时出现了异常，会把之前所有的线程都安全关闭掉</span><br><span class="line">                            int j;</span><br><span class="line">                            for(j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">                                this.children[j].shutdownGracefully();</span><br><span class="line">                            &#125;</span><br><span class="line">                            ...</span><br><span class="line">                        &#125;&#125;&#125;</span><br><span class="line">      ...</span><br><span class="line">	&#125;</span><br><span class="line">	this.chooser = chooserFactory.newChooser(this.children);</span><br><span class="line">    FutureListener&lt;Object&gt; terminationListener = new FutureListener&lt;Object&gt;() &#123;</span><br><span class="line">    public void operationComplete(Future&lt;Object&gt; future) throws Exception &#123;</span><br><span class="line">          if(MultithreadEventExecutorGroup.this.terminatedChildren.incrementAndGet() == 					MultithreadEventExecutorGroup.this.children.length) &#123;</span><br><span class="line">           MultithreadEventExecutorGroup.this.terminationFuture.setSuccess((Object)null);</span><br><span class="line">           &#125;&#125;</span><br><span class="line">      	&#125;;</span><br><span class="line">            EventExecutor[] var24 = this.children;</span><br><span class="line">            j = var24.length;</span><br><span class="line">            //对线程组中的每个NioEventLoop实例增加FutureListener监听器</span><br><span class="line">            for(int var26 = 0; var26 &lt; j; ++var26) &#123;</span><br><span class="line">                EventExecutor e = var24[var26];</span><br><span class="line">                e.terminationFuture().addListener(terminationListener);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ServerBootStrap配置</strong></p>
<p>ServerBootStrap用于服务端引导配置，包括设置线程组、通道类型、通道处理器等。</p>
<blockquote>
<p>new ServerBootStrap()</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	public class ServerBootstrap extends AbstractBootstrap&lt;ServerBootstrap, ServerChannel&gt; &#123;</span><br><span class="line">   private final Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = new ConcurrentHashMap();</span><br><span class="line">   private final Map&lt;AttributeKey&lt;?&gt;, Object&gt; childAttrs = new ConcurrentHashMap();</span><br><span class="line">   private final ServerBootstrapConfig config = new ServerBootstrapConfig(this);</span><br><span class="line">   private volatile EventLoopGroup childGroup;</span><br><span class="line">   private volatile ChannelHandler childHandler;</span><br><span class="line">private static final InternalLogger logger = 	 </span><br><span class="line">                              InternalLoggerFactory.getInstance(ServerBootstrap.class);</span><br><span class="line">   public ServerBootstrap() &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>发现构造器并没做什么，但是类的相关属性都初始化了。</p>
<blockquote>
<p>group(bossgroup,workergroup)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) &#123;</span><br><span class="line">    //AbstracServerBootstrap父类的group方法执行</span><br><span class="line">    super.group(parentGroup);</span><br><span class="line">    ObjectUtil.checkNotNull(childGroup, &quot;childGroup&quot;);</span><br><span class="line">    if (this.childGroup != null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;childGroup set already&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    	//赋值childgroup属性，然后返回实例</span><br><span class="line">        this.childGroup = childGroup;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//AbstracServerBootStrap group方法</span><br><span class="line">public B group(EventLoopGroup group) &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(group, &quot;group&quot;);</span><br><span class="line">    if (this.group != null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;group set already&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    	//赋值group属性</span><br><span class="line">        this.group = group;</span><br><span class="line">        return this.self();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>channel(NioServerSocketChannel.class)</p>
</blockquote>
<p>设置服务端通道类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//使用AbstractServerBootStrap的channel方法，将ReflectiveChannelFactory实例赋给channelFactory属  //性，并且设置ReflectiveChannelFactory实例的construct属性为传进去的channelClass的construct</span><br><span class="line">public B channel(Class&lt;? extends C&gt; channelClass) &#123;</span><br><span class="line">		//使用反射通道工厂设置通道，就是根据class类型反射创建实例</span><br><span class="line">        return this.channelFactory((io.netty.channel.ChannelFactory)(new ReflectiveChannelFactory((Class)ObjectUtil.checkNotNull(channelClass, &quot;channelClass&quot;))));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">//调用到最底层类ReflectiveChannelFactory的构造方法 </span><br><span class="line">public ReflectiveChannelFactory(Class&lt;? extends T&gt; clazz) &#123;</span><br><span class="line">        ObjectUtil.checkNotNull(clazz, &quot;clazz&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">        	//将通道类型的构造器赋值</span><br><span class="line">            this.constructor = clazz.getConstructor();</span><br><span class="line">        &#125; catch (NoSuchMethodException var3) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Class &quot; + StringUtil.simpleClassName(clazz) + &quot; does not have a public non-arg constructor&quot;, var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> //并且将ReflectiveChannelFactory实例赋给AbstractServerBootstrap的channelFactory属性</span><br><span class="line"> public B channelFactory(ChannelFactory&lt;? extends C&gt; channelFactory) &#123;</span><br><span class="line">        ObjectUtil.checkNotNull(channelFactory, &quot;channelFactory&quot;);</span><br><span class="line">        if (this.channelFactory != null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;channelFactory set already&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.channelFactory = channelFactory;</span><br><span class="line">            return this.self();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>option(ChannelOption.SO_BACKLOG,100)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//AbstractBootstrap的方法</span><br><span class="line">public &lt;T&gt; B option(ChannelOption&lt;T&gt; option, T value) &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(option, &quot;option&quot;);</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        this.options.remove(option);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //其实是给optionmap中插入数据</span><br><span class="line">        this.options.put(option, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this.self();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>handler(new LoggingHandler(LogLevel.INFO))</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//AbstractBootstrap的方法，给handler属性赋值</span><br><span class="line">public B handler(ChannelHandler handler) &#123;</span><br><span class="line">        this.handler = (ChannelHandler)ObjectUtil.checkNotNull(handler, &quot;handler&quot;);</span><br><span class="line">        return this.self();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ChannelFuture f = b.bind(port).sync()</strong></p>
<p>最核心的部分，绑定端口并运行服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">—— ——&gt;</span><br><span class="line">//AbstractBootstrap类的bind方法</span><br><span class="line"> public ChannelFuture bind(int inetPort) &#123;</span><br><span class="line">        return this.bind(new InetSocketAddress(inetPort));</span><br><span class="line"> &#125;</span><br><span class="line">—— ——&gt;</span><br><span class="line">public ChannelFuture bind(SocketAddress localAddress) &#123;</span><br><span class="line">        this.validate();</span><br><span class="line">        return this.doBind((SocketAddress)ObjectUtil.checkNotNull(localAddress, &quot;localAddress&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"> —— ——&gt;</span><br><span class="line"> //最底层的方法</span><br><span class="line"> private ChannelFuture doBind(final SocketAddress localAddress) &#123;</span><br><span class="line">        //initAndRegister方法进行初始化和注册</span><br><span class="line">        final ChannelFuture regFuture = this.initAndRegister();</span><br><span class="line">        final Channel channel = regFuture.channel();</span><br><span class="line">        if (regFuture.cause() != null) &#123;</span><br><span class="line">            return regFuture;</span><br><span class="line">        &#125; else if (regFuture.isDone()) &#123;</span><br><span class="line">            ChannelPromise promise = channel.newPromise();</span><br><span class="line">            doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">            return promise;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            final AbstractBootstrap.PendingRegistrationPromise promise = new AbstractBootstrap.PendingRegistrationPromise(channel);</span><br><span class="line">            regFuture.addListener(new ChannelFutureListener() &#123;</span><br><span class="line">                public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">                    Throwable cause = future.cause();</span><br><span class="line">                    if (cause != null) &#123;</span><br><span class="line">                        promise.setFailure(cause);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        promise.registered();</span><br><span class="line">                        //关键bind方法</span><br><span class="line">                        AbstractBootstrap.doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            return promise;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  —— —— —— ——&gt;</span><br><span class="line">  final ChannelFuture initAndRegister() &#123;</span><br><span class="line">        Channel channel = null;</span><br><span class="line">        try &#123;</span><br><span class="line">        	//通过channelFactory通道工厂属性的newChannel方法创建channel</span><br><span class="line">        	/**因为之前已经将flectiveChannelFactory实例赋给channelFactory属性</span><br><span class="line">        	*flectiveChannelFactory的newChannel()方法实现为</span><br><span class="line">        	*  return (Channel)this.constructor.newInstance();</span><br><span class="line">        	* 通过构造器反射创建channel实例，即NioServerSocketChannel实例</span><br><span class="line">        	**/</span><br><span class="line">            channel = this.channelFactory.newChannel();</span><br><span class="line">            this.init(channel);</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            if (channel != null) &#123;</span><br><span class="line">                channel.unsafe().closeForcibly();</span><br><span class="line">                return (new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE)).setFailure(var3);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return (new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE)).setFailure(var3);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		/**</span><br><span class="line">		* 这个方法是将nioServerSocketChannel注册到bossgroup中</span><br><span class="line">		* group()返回是bossgroup，register()先使用next()得到bossgroup的一个线程，然后绑定通道</span><br><span class="line">		*</span><br><span class="line">		**/</span><br><span class="line">        ChannelFuture regFuture = this.config().group().register(channel);</span><br><span class="line">        if (regFuture.cause() != null) &#123;</span><br><span class="line">            if (channel.isRegistered()) &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                channel.unsafe().closeForcibly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return regFuture;</span><br><span class="line">    &#125;</span><br><span class="line">—— —— —— —— ——</span><br><span class="line">//ServerBootStrap类的init方法实现</span><br><span class="line">   void init(Channel channel) &#123;</span><br><span class="line">   		//给channel的config绑定optionmap的键值对</span><br><span class="line">        setChannelOptions(channel, (Entry[])this.options0().entrySet().toArray(newOptionArray(0)), logger);</span><br><span class="line">        setAttributes(channel, (Entry[])this.attrs0().entrySet().toArray(newAttrArray(0)));</span><br><span class="line">        //获得NioServerSocketChannel通道的管道</span><br><span class="line">        ChannelPipeline p = channel.pipeline();</span><br><span class="line">        final EventLoopGroup currentChildGroup = this.childGroup;</span><br><span class="line">        final ChannelHandler currentChildHandler = this.childHandler;</span><br><span class="line">        final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions = (Entry[])this.childOptions.entrySet().toArray(newOptionArray(0));</span><br><span class="line">        final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = (Entry[])this.childAttrs.entrySet().toArray(newAttrArray(0));</span><br><span class="line">        //加入NioServerSocketChannel通道的处理器</span><br><span class="line">        p.addLast(new ChannelHandler[]&#123;new ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">            public void initChannel(final Channel ch) &#123;</span><br><span class="line">                final ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                //获得ServerBootstrap的channelhandler属性</span><br><span class="line">                ChannelHandler handler = ServerBootstrap.this.config.handler();</span><br><span class="line">                if (handler != null) &#123;</span><br><span class="line">                	//如果事先设置，则向NioServerSocketChannel的peipeline尾部添加handler</span><br><span class="line">                	/**</span><br><span class="line">                	 * 这个handler是serverbootstrap的handler()方法的参数，在这里是</span><br><span class="line">                     * logginghandler</span><br><span class="line">                	 **/</span><br><span class="line">                    pipeline.addLast(new ChannelHandler[]&#123;handler&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			/**</span><br><span class="line">			* 这段代码作用是：ch.eventLoop()即bossgroup的线程，向nioServerSocketChannel的</span><br><span class="line">			* pipeline尾部加了ServerBootstrapAcceptor接收器，监听等待客户端的连接</span><br><span class="line">			**/</span><br><span class="line">                ch.eventLoop().execute(new Runnable() &#123;</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        pipeline.addLast(new ChannelHandler[]&#123;new ServerBootstrap.ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ChannelFuture regFuture = this.config().group().register(channel);</p>
</blockquote>
<p>看下initAndRegister()方法中的这行代码，作用是将使用bossgroup线程组注册nioServerSocketChannel通道。其实主要干了两件事：</p>
<p>1、先使用next()获得bossgroup的一个线程，然后execute执行register0(promise)。</p>
<p>​    promise是将NioServerSocketChannel和NioEventLoop封装在一起的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

<p>2、register0(promise)方法最底层调用到了AbstractNioChannel类的doRegister()方法。下面这行代码就是这个方法的核心，这个不就是nio中将选择器注册到通道中吗！当然执行这整个过程都是在bossgroup的eventLoop线程中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.selectionKey = this.javaChannel().register(this.eventLoop().unwrappedSelector(), 0, this);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p><strong>initAndRegister()方法</strong>之后进入到核心方法 <code>AbstractBootstrap.doBind0(regFuture, channel, localAddress, promise)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">—— —— —— ——&gt;</span><br><span class="line">AbstractBootstrap.bind0方法内调用了   </span><br><span class="line">channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line"></span><br><span class="line">—— —— —— ——&gt;</span><br><span class="line">调用到DefaultChannelHandlerPipeline类中的bind(SocketAddress localAddress, ChannelPromise promise)</span><br><span class="line">—— —— —— ——&gt;</span><br><span class="line">调用到AbstractChannelHandlerContext类中的 bind(final SocketAddress localAddress, final ChannelPromise promise) </span><br><span class="line">方法里使用了  next.invokeBind(localAddress, promise);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">—— —— —— ——&gt;</span><br><span class="line">跳出bind方法后会跳到SingleThreadEventExecutor线程类的runAllTasks方法</span><br><span class="line"></span><br><span class="line">—— —— —— ——&gt;</span><br><span class="line">执行完后跳到NioEventLoop类的run()方法</span><br><span class="line">这个方法中有两个很重要的方法</span><br><span class="line">1、this.processSelectedKeys();</span><br><span class="line">2、  this.runAllTasks();</span><br><span class="line">因为之前已经在NioEventLoop中给ServerSocketChannel通道注册了选择器，所以</span><br><span class="line">当有客户端和服务端连接时，NioEventLoop线程监听到连接事件，会让childgroup的线程组执行处理这些连接，并且不断循环监听事件。</span><br></pre></td></tr></table></figure>

<p>这个过程其实很复杂，涉及到线程操作。先进行简单分析。 </p>
</li>
<li><p><strong>NioServerSocketChannel和Pipeline、ChannelHandler、ChannelHandlerContext的关系</strong></p>
<p>在<code>initAndRegister()</code>方法中，使用channelFactory通道工厂给channel赋值生成NioServerSocketChannel实例，channel中相关的属性如下：</p>
<p><img src="/max.github.io/2020/03/01/netty启动过程分析/netty%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90.png" alt="netty启动过程分析"></p>
<blockquote>
<p>包含一个pipeline属性</p>
</blockquote>
<p>pipeline属性初始为DefaultChannelPipeline实例，<code>DefaultChannelPipeline</code>是一个双链表结构，包含head、tail头尾结点，更具体的看head头结点是DefaultChannelPipeline中的HeadContext内部类，tail尾结点是TailContext内部类，并且头尾结点是AbstractChannelHandlerContext类型，从其源码可以应证： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultChannelPipeline implements ChannelPipeline &#123;</span><br><span class="line">//头结点</span><br><span class="line">final AbstractChannelHandlerContext head;</span><br><span class="line">//尾结点</span><br><span class="line">final AbstractChannelHandlerContext tail;</span><br><span class="line">//pipeline也可以获得channel实例</span><br><span class="line">private final Channel channel;</span><br><span class="line"></span><br><span class="line">protected DefaultChannelPipeline(Channel channel) &#123;</span><br><span class="line">    this.channel = (Channel)ObjectUtil.checkNotNull(channel, &quot;channel&quot;);</span><br><span class="line">    this.succeededFuture = new SucceededChannelFuture(channel, (EventExecutor)null);</span><br><span class="line">    this.voidPromise = new VoidChannelPromise(channel, true);</span><br><span class="line">    this.tail = new DefaultChannelPipeline.TailContext(this);</span><br><span class="line">    this.head = new DefaultChannelPipeline.HeadContext(this);</span><br><span class="line">    //初始头结点next指向尾结点，尾结点prev指向头结点</span><br><span class="line">    this.head.next = this.tail;</span><br><span class="line">    this.tail.prev = this.head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">final class HeadContext extends AbstractChannelHandlerContext implements ChannelOutboundHandler, ChannelInboundHandler &#123;...&#125;</span><br><span class="line"></span><br><span class="line">final class TailContext extends AbstractChannelHandlerContext implements ChannelInboundHandler &#123;...&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于channelhandler怎么关联，可以继续看pipeline的方法<code>addLast(String name, ChannelHandler handler)</code> ，有可以不带name参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//调用更底层方法</span><br><span class="line">public final ChannelPipeline addLast(String name, ChannelHandler handler) &#123;</span><br><span class="line">    return this.addLast((EventExecutorGroup)null, name, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) &#123;</span><br><span class="line">	//创建AbstractChannelHanderContext实例</span><br><span class="line">    AbstractChannelHandlerContext newCtx;</span><br><span class="line">    //保证多线程添加的安全</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line">        /**</span><br><span class="line">        * 这个方法返回一个DefaultChannelHandlerContext实例，这个类是AbstractChannelHandler</span><br><span class="line">        * Context的子类，并且多了一个channelhandler属性，将handler赋给channelhandler属性</span><br><span class="line">        **/</span><br><span class="line">        newCtx = this.newContext(group, this.filterName(name, handler), handler);</span><br><span class="line">        //然后将channelhandlercontext添加到tail结点的前面</span><br><span class="line">        this.addLast0(newCtx);</span><br><span class="line">        if (!this.registered) &#123;</span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            this.callHandlerCallbackLater(newCtx, true);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        EventExecutor executor = newCtx.executor();</span><br><span class="line">        if (!executor.inEventLoop()) &#123;</span><br><span class="line">            this.callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.callHandlerAdded0(newCtx);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次使用addLast方法添加channelhandler时，会先创建一个DefaultChannelHandlerContext实例，将channlehandler赋给这个实例的channelhandler属性，然后将这个实例添加到pipeline的尾结点前面。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/max.github.io/2019/06/26/杂想/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/max.github.io/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/max.github.io/2019/06/26/杂想/" itemprop="url">杂想</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-26T23:26:02+08:00">
                2019-06-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/max.github.io/categories/杂想/" itemprop="url" rel="index">
                    <span itemprop="name">杂想</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>​                                  </p>
<p>​                         <img src="/max.github.io/2019/06/26/杂想/zaxiang.gif" alt="zaxiang"></p>
<p>​    </p>
<p>​    朝着目标慢慢的也走到了现在，人总会有疲倦的时候，啥也不想干，正好整理下思绪。</p>
<p>​    六个月前，差不多也是这个月底的样子，学校安排了机构单位来校讲课，机缘巧合选择了大数据的课堂。冥冥中总有天意，碰到了给我们授课的许亮师兄，为啥是师兄呢？刚好他也是我们学校毕业的，之后和他聊了不少，当时到了大三，虽然生活还是一如既往的平静，但随之而来的就是就业的考虑。普通的学校，普通的经历，然后只能操起一门语言，准备工作了。就这样和室友们一起选择了java，因为在当时也差不多03、04年的样子，刚值国内流行java环境也好。最后顺利的拿了工作，工作几年跳槽到了华为，干了6年就又到了现在的公司，凭着丰富的经历经验和扎实的专业技能当上了机构的总监。那为啥要说师兄呢？</p>
<p>​    当时的我也是大三，一样的大学生活，没进实验室，也没弄什么比赛，不过自己倒保持着专业的兴趣，私下跟着教程做些小玩意，捣鼓Linux、python、网络安全等等，因为单纯的兴趣，也没考虑以后是否要干哪一方面，所以学的知识不系统、深入。慢慢的决定了找工作，然后就选了喜欢的一门语言—python。就在网上(主要还是知乎)到处找学习路线，需要看的书。那时候，自学的状态其实在现在看来，还是不太满意的，思维有时很混乱，学习的方法也不太实用，总之感觉效率不太高。当时主要是看文档，也没买书籍，看的都是电子书，视频看的也少，整理也少。直接看文档也时总感觉晦涩，应该是要求的基础还没达标，然后文档作为基础知识的载体，效率也不太高，感觉比不上视频。看完视频能学会用就行，在实践的过程中遇到问题，看文档、逛帖子、看博客啊，这些都是别人相似的问题总结出的经验，避免了我们走不少弯路。就这样，不断完善学习语言的方法，来到了效率正常的一档子。但是，基础和经历还是欠缺的，这也是我后面慢慢加强的地方。</p>
<p>​    回到师兄的话题😂那时候身边的一些同学进了实验室，跟着老师做项目，学的是java。而我自学python，越学越没底，感觉我学的不太深入，这样咋找工作。等到最后一堂课结束，我和师兄聊了很久，请教他给我指导下，规划下路线。师兄说，其实任何一门语言没有好坏，只要学的深学的扎实。他看得出我着急就业，加上我们学校也没啥竞争力，说如果想找一个好的工作，可以学java，毕竟现在python工程师岗位在国内还是不太多的，有和我分析了python语言的特点和未来发展，可以考虑作为第二语言技能，主学还是java。等以后按照发展，再考虑其他的语言学习。就这样，走上了一去不回的java之路了。</p>
<p>​    到现在半年的积累，还是学了挺多的，慢慢改善学习方法，思考方法，完善知识基础、项目经历。虽然现在还有很多知识去总结，有些还没学扎实，项目进度也稍微急，还是尽量去做吧。两三个月，好好把握下👌。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/max.github.io/2019/06/20/HashMap、ConccurrentHashMap和HashTable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/max.github.io/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/max.github.io/2019/06/20/HashMap、ConccurrentHashMap和HashTable/" itemprop="url">HashMap、ConccurrentHashMap和HashTable</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-20T10:34:18+08:00">
                2019-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/max.github.io/categories/集合容器/" itemprop="url" rel="index">
                    <span itemprop="name">集合容器</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/max.github.io/2019/06/20/HashMap底层实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/max.github.io/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/max.github.io/2019/06/20/HashMap底层实现/" itemprop="url">HashMap底层实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-20T10:32:26+08:00">
                2019-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/max.github.io/categories/集合容器/" itemprop="url" rel="index">
                    <span itemprop="name">集合容器</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="HashMap的相关继承关系"><a href="#HashMap的相关继承关系" class="headerlink" title="HashMap的相关继承关系"></a>HashMap的相关继承关系</h6><p><img src="/max.github.io/2019/06/20/HashMap底层实现/hashmap.png" alt="hashmap">  </p>
<p>HashMap是使用频率最高的用于映射(键值对)处理的数据类型，jdk1.7和jdk1.8开始，hashmap的底层使用发生了改变。下面就从源码上分析hashmap的结构功能。</p>
<h6 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h6><p>hashmap是散列表(哈希表)的一个应用的实现。</p>
<p>散列表的结构：用链表数组实现，相比于链表和数组，可以很快的查找到所要的对象。</p>
<p>散列码：散列表为每个对象计算一个整数，即散列码(hash code)。散列码由对象的数据域产生，不同的数据域的对象的散列码不同。</p>
<h6 id="hashmap的内部结构"><a href="#hashmap的内部结构" class="headerlink" title="hashmap的内部结构"></a>hashmap的内部结构</h6><p><img src="/max.github.io/2019/06/20/HashMap底层实现/%E7%BB%93%E6%9E%84.png" alt="结构"></p>
<p>看下hashmap的结构的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   //指向下一个Entry，单链表结构</span><br><span class="line"></span><br><span class="line">        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            this.hash = hash;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>又实现了一个内部类Node作为基本元素，继承于Entry。Node包含一对键值对和next指针，和key的hash码。数组的每个位置对应着一条单链表，链表的表头存放在数组中。</p>
<h6 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h6><p>hashmap的列表称为桶，计算某个对象该位于哪个列表的链表中：</p>
<p>1.计算对象的hashcode</p>
<p>2.hashcode对散列表中桶的总数求余，即为对象所在”桶“的索引</p>
<p>3.确定该”桶“对应链表中有没有相同hashcode的对象，没有就继续插入，有就替换</p>
<p>如果对象插入时遇到所有的”桶“都用完了，即在相同的”桶“中插入对象，这种现象称为<strong>散列冲突</strong>。然后按3中插入。如果”桶“的数目足够大，需要比较的次数就会很少。</p>
<h6 id="看下源码怎么确定hash桶数的索引"><a href="#看下源码怎么确定hash桶数的索引" class="headerlink" title="看下源码怎么确定hash桶数的索引"></a>看下源码怎么确定hash桶数的索引</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//计算对象的hashcode </span><br><span class="line">static final int hash(Object key) &#123;   </span><br><span class="line">     int h;</span><br><span class="line">     h = key.hashCode() 第一步 取hashCode值</span><br><span class="line">     h ^ (h &gt;&gt;&gt; 16)  第二步 高位参与运算</span><br><span class="line">     return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回桶的索引</span><br><span class="line"> static int indexFor(int h, int length) &#123;</span><br><span class="line">        return h &amp; (length-1); 第三步 取模</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低位都参与到Hash的计算中，同时不会有太大的开销。</p>
<p>参考下图：</p>
<p><img src="/max.github.io/2019/06/20/HashMap底层实现/hashcode.png" alt="hashcode"></p>
<h6 id="HashMap的put方法"><a href="#HashMap的put方法" class="headerlink" title="HashMap的put方法"></a>HashMap的put方法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//put方法</span><br><span class="line"> public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)</span><br><span class="line"> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;				//复制局部hashmap，操作不会影响类</span><br><span class="line">   // 步骤①：tab为空则创建</span><br><span class="line">   if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">   // 步骤②：计算index，并对null做处理         </span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);		//赋值第一个节点</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        // 步骤③：节点key存在，直接覆盖value</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">         // 步骤④：判断该链为红黑树</span><br><span class="line">        else if (p instanceof TreeNode)					//如果节点在红黑树中</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        // 步骤⑤：该链为链表</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    //链表长度大于8转换为红黑树进行处理</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                 // key已经存在直接覆盖value</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e != null) &#123; // existing mapping for key     //统一覆盖值，修改为新的键值</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    // 步骤⑥：超过最大容量 就扩容</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个流程图有助于理解些：</p>
<p><img src="/max.github.io/2019/06/20/HashMap底层实现/%E6%B5%81%E7%A8%8B.png" alt="流程"></p>
<h6 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h6><p>扩容(resize)机制：当向hashmap不停地添加元素，而内部地数组无法装载更多的元素时，就需要扩大数组的长度，减少hash冲突。简单来说，扩容就是再创建一个散列表，增加数组的长度，将原来的元素复制到相同的位置。类似于ArrayList的扩容机制，Arrays.copyOf复制新的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">		//创建一个新的数组</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        //获取原来数组的长度</span><br><span class="line">        int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">        //hashmap的扩容阀值</span><br><span class="line">        int oldThr = threshold;</span><br><span class="line">        int newCap, newThr = 0;</span><br><span class="line">        </span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">        //判断旧数组的长度是否超过 MAXIMUM_CAPACITY (2的30次方)，超过则将MAX_VALUE赋给阀值，不扩容</span><br><span class="line">            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                return oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">        //旧数组长度大于DEFAULT_INITIAL_CAPACITY（数组默认的长度16），旧数组长度乘2赋给新数组</span><br><span class="line">            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; 1; // double threshold          //新的阀值为旧阀值乘2</span><br><span class="line">        &#125;</span><br><span class="line">        //数组中没有元素，阀值已经赋值，初始化数组，长度为默认阀值16</span><br><span class="line">        else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        //阀值为0时，数组大小赋值为16，新的阀值为加载因子(0.75)*16</span><br><span class="line">       else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        //计算新的resize上限</span><br><span class="line">        if (newThr == 0) &#123;</span><br><span class="line">            float ft = (float)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        </span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        if (oldTab != null) &#123;</span><br><span class="line">    		// 把每个bucket都移动到新的buckets中</span><br><span class="line">            for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                    oldTab[j] = null;</span><br><span class="line">                    if (e.next == null)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                    else if (e instanceof TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                    else &#123; // preserve order</span><br><span class="line">                    // 链表优化重hash的代码块</span><br><span class="line">                        Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        do &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                             // 原索引</span><br><span class="line">                            if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                                if (loTail == null)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            // 原索引+oldCap</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if (hiTail == null)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; while ((e = next) != null);</span><br><span class="line">                        // 原索引放到bucket里</span><br><span class="line">                        if (loTail != null) &#123;</span><br><span class="line">                            loTail.next = null;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 原索引+oldCap放到bucket里</span><br><span class="line">                        if (hiTail != null) &#123;</span><br><span class="line">                            hiTail.next = null;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，因为赋值元素时使用的是<strong>头插法</strong>，JDK1.8会重新hash改变索引位置，元素不会倒置。</p>
<h6 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h6><p>在多线程使用场景中，应该尽量避免使用线程不安全的hashmap，使用线程安全的ConcurrentHashMap。</p>
<p>HashMap在并发场景下可能造成的问题：</p>
<ul>
<li>数据丢失</li>
<li>数据重复</li>
<li>死循环</li>
</ul>
<p>1.死循环</p>
<p> 在jdk1.7中，由于resize中链表的元素会倒置，所以会造成死循环。而在jdk1.8中，链表元素不会倒置，就不会发生。</p>
<p>2.数据丢失</p>
<p> 看扩容的过程，在jdk1.7中，Entry&lt;K,V&gt; e = src[j] ，e是指向旧table的元素。在多线程中，只有一个公共的table，也没有加volitate关键字修饰内存可见。可能会出现以下的情况：</p>
<p>线程A   先完成扩容</p>
<p>线程B    在扩容过程中，e.next指向了线程A完成扩容后的对应位置，将原来next指向的元素丢失了。</p>
<p>3.数据重复</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/max.github.io/page/2/">2</a><a class="extend next" rel="next" href="/max.github.io/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/max.github.io/images/avatar.jpg" alt="Max">
            
              <p class="site-author-name" itemprop="name">Max</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/max.github.io/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/max.github.io/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/max.github.io/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        
<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Max</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/max.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/max.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/max.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/max.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/max.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/max.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/max.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/max.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/max.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/max.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/max.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
