<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/max.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/max.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/max.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/max.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/max.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/max.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/max.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/max.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
	<a href="https://github.com/isMaxaaa" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/max.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/max.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/max.github.io/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/max.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/max.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/max.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/max.github.io/2020/05/09/并发之可重入锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/max.github.io/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/max.github.io/2020/05/09/并发之可重入锁/" itemprop="url">并发之可重入锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-09T23:54:54+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/max.github.io/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>​                                 </p>
<img src="/max.github.io/2020/05/09/并发之可重入锁/主题.png" alt="主题">

<h3 id="并发之可重入锁"><a href="#并发之可重入锁" class="headerlink" title="并发之可重入锁"></a>并发之可重入锁</h3><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>Java协调共享对象的访问时关机制有synchronized、volatile，Java5.0后新增了一种机制：ReentrantLock。前面两个是Java内置的关键字，可以说是内置锁。ReentrantLock可以称作是显示锁，因为其使用时加锁、解锁是显示的。也可以称作可重入锁，因为使用时同一个线程可以重复获得锁，而不会阻塞。除此之外，ReentrantLock还有更丰富的特性：公平\非公平性，可响应中断，定时等。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><ul>
<li><p>重入性</p>
<p>ReentrantLock内部主要实现依赖于AQS(感兴趣可以看下之前的文章<a href="https://max-24.github.io/max.github.io/2020/05/03/AQS原理解析/" target="_blank" rel="noopener">AQS原理解析</a>)，可重入性比较好理解，独占锁获锁的实现是CAS操作同步变量expect为0，update为1。可重入则是CAS操作同步变量，expect为当前同步变量值c，update为c+1。每次释放时，线程获得的同步变量就会减一。当然具体的逻辑不止这些，在实现中具体分析。</p>
</li>
<li><p>公平性</p>
<p>ReentrantLock另一个重要的特性就是公平性。公平与非公平是针对线程获取锁的方式。ReentrantLock为公平锁时，线程会按照他们发出的请求顺序获得锁，如果已经有线程获得了锁或者有线程在同步队列等待锁，该线程就会放入到队列尾部。ReentrantLock为非公平锁时，线程则允许”插队”获取锁，具体来说，当同步状态为0时，线程可以跨越同步队列的线程尝试获取锁，只有当锁已被其它线程持有，才会放入同步队列。</p>
<p>那么怎么使用公平与非公平呢？其实非公平具有更高的吞吐量，来看下这个场景：非公平锁的机制下，线程A获得了锁，线程B还在同步队列中阻塞等待。这一时刻，线程A释放了锁，然后唤醒线程B去获取锁，但是，此时在线程B还未唤醒时，线程C抢先获取锁，充分利用了这段空闲时间，当然没有影响线程B的唤醒去获取锁。这种情况下，提高了线程的吞吐量。</p>
<blockquote>
<p>注意，如果线程持有锁的时间比较长或者请求锁的时间比较长，公平和非公平区别就不大了。</p>
</blockquote>
</li>
</ul>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>ReentrantLock实现了Lock接口，只有一个属性，内部静态类Sync对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Sync sync; </span><br><span class="line">       </span><br><span class="line">       <span class="comment">//构造器默认返回非公平锁</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//也可以指定公平性</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>看下Lock接口的方法</li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void lock()</td>
<td align="center">获取锁</td>
</tr>
<tr>
<td align="center">void lockInterruptibly() throws InterruptedException</td>
<td align="center">获取锁，如果失败在等待中可以响应中断并抛出异常</td>
</tr>
<tr>
<td align="center">Condition newCondition()</td>
<td align="center">返回Lock绑定的condition对象</td>
</tr>
<tr>
<td align="center">boolean tryLock()</td>
<td align="center">尝试获取锁，如果失败会立即返回false，不会等待</td>
</tr>
<tr>
<td align="center">boolean tryLock(long time, TimeUnit unit) throws InterruptedException</td>
<td align="center">尝试获取锁，如果失败会停留一段指定的时间，时间到了如果没有获取返回false，并且可以响应中断</td>
</tr>
<tr>
<td align="center">void unlock()</td>
<td align="center">释放锁</td>
</tr>
</tbody></table>
<ul>
<li><p>Sync内部类</p>
<p>Sync继承了AQS，也是ReentrantLock的核心。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lock方法，留给内部类公平锁和非公平锁实现</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非公平锁的TryAcquire实现</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">//获得当前lock锁的同步状态变量</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果c=0，说明锁此时未被线程获取，CAS尝试获取锁，如果成功设置当前线程为锁的独占线程</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread())</span><br><span class="line">            <span class="comment">//如果c&gt;0，并且当前线程就是锁的拥有者，可重复获取锁</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="comment">//更新同步状态变量</span></span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AQS的tryRelease的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前同步变量减去release</span></span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="comment">//如果当前线程不是锁的独占线程而进行释放，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//如果更新的c为0，说明锁完全释放，设置独占线程为空。否则c&gt;0,说明锁被重入了，未完全释放。</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新同步状态变量</span></span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断当前线程是否获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ReentrantLock的公平锁和非公平锁都继承了Sync内部类，主要区别在于锁的获取过程，公平锁如果未重入，同步队列中前面必须没有比当前线程等待时间更长的线程。非公平锁则不受限制。二者如果都获取失败了，都放入AQS同步队列中循环等待。</p>
</blockquote>
<h6 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">//lock实现调用AQS的acquire(),tryAcquire()由FairSync实现</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果失败，就放入同步队列中循环等待</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//当c为0，当前没有锁获取线程时，还需要hasQueuedPredecessors()判断同步队列中</span></span><br><span class="line">            <span class="comment">//是否有比当前线程等待时间更长的线程。如果有，直接返回false。</span></span><br><span class="line">            <span class="comment">//没有则进行CAS获取同步状态变量，然后设置独占线程</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">//如果当前线程已经获取了锁，进行重入</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//不用等同步队列前面的线程，直接进行CAS操作。</span></span><br><span class="line">    <span class="comment">//先进行CAS设置同步状态变量，如果失败，调用AQS的acquire(),tryAcquire()由Sync中nonfairTryAcquire实现</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="ReentrantLock其它重要方法"><a href="#ReentrantLock其它重要方法" class="headerlink" title="ReentrantLock其它重要方法"></a>ReentrantLock其它重要方法</h6><ul>
<li>lock()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//直接调用公平、非公平锁的lock实现方法 </span></span><br><span class="line">   sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>tryLock()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试获取锁，注意调用的是非公平锁的tryAcquire()</span></span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>unlock()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用sync的release()</span></span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p>ReentrantReadWriteLock俗称“读写锁”，是ReentrantLock的升级版。ReentrantLock的可重入性的确使AQS的锁获取更加丰富，但是终究锁同时只能被一个线程获取，只能一个线程“写”，也只能一个线程“读”，具有很强的”互斥性“。带来的问题是：大多数情况，程序进行读操作时，就大大限制了并发性。当然写操作只能一个线程进行。那这样是不是可以修改一下ReentranLock，读操作时可以多个线程获取同一把读锁，写操作时只能一个线程获取写锁。但是注意二者不能同时进行，读操作时不能进行写操作，否则会出现数据不一致。</p>
<h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><ul>
<li><p>实现核心</p>
<p>读写锁的实现核心还是基于AQS，和ReentrantLock不同，内部有读锁、写锁，分别是ReadLock、WriteLock内部类实现。而他们的核心也是内部类Sync实现，其中设计了读写状态，表示读写锁的状态。具体在实现中再分析。</p>
</li>
<li><p>公平非公平性</p>
<p>读写锁也有公平和非公平之分，公平锁模式下，等待时间最长的线程将优先获取锁。如果这个锁由读线程持有，现在有另一个线程请求写锁，那么其它读线程都不能请求读锁，只能等写线程释放锁后再获取。在非公平锁模式下，线程获取访问的顺序是随机的。</p>
</li>
<li><p>锁降级</p>
<p>锁降级指写锁降为读锁，如果当前线程获取写锁，然后获取读锁，最后释放写锁。为什么出现锁降级呢？比如一个线程进行比较复杂的写操作，通常又分为几个事务进行，可能消耗的时间过长进而使其它的读操作收到影响，但是写操作又没完全完成，这是就采用”锁降级“，获取读锁，先进行读操作。等事务都完成后，再释放写锁。</p>
<blockquote>
<p>还要注意的是先获取读锁，再释放写锁。而不是释放完写锁，紧接着获取读锁。当前线程A如果直接释放了写锁，可能这是另一个线程B获取了写锁，还修改了数据，然后A线程获取了读锁，但是完全不知数据发生了修改，导致了数据的不一致性。但是如果先获取读锁，此时不允许有线程获取写锁，直到获取读锁完成了。所以先获取读锁，再释放写锁，是为了数据的可见性。</p>
</blockquote>
</li>
</ul>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><p>ReentrantReadWriteLock实现了ReadWriteLock接口，包含读锁和写锁。ReadWriteLock只有两个方法：<code>writeLock()</code>返回写锁，<code>readLock()</code>返回读锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部类读锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="comment">//内部类写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">    <span class="comment">//实现了AQS，Sync内部类</span></span><br><span class="line">    <span class="keyword">final</span> Sync sync; </span><br><span class="line">    <span class="comment">//返回某个线程的tid</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TID_OFFSET;</span><br><span class="line">    <span class="comment">//默认构造器，非公平读写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指定公平性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">        <span class="comment">//创建读锁、写锁对象</span></span><br><span class="line">        readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h6><p>Sync是读写锁的核心，实现了AQS，读写锁的公平和非公平模式就是继承这个内部类。Sync含有两个内部类，HoldCounter、ThreadLocalHoldCounter。</p>
<blockquote>
<p>HoldCounter记录线程的获取读锁的数量，ThreadLocalHoldCounter保存每个线程的获取锁的信息</p>
</blockquote>
<p>AQS使用同步状态变量state记录锁的获取次数，获取就+1，释放就-1。而读写锁含有两个锁，怎么使用一个变量保存呢？读写锁采用对int32位同步变量的高低位表示，高16位表示读锁的数量，低16位标识写锁的数量。怎么保证读锁、写锁获取正确顺序呢？也可以通过同步变量体现，如果低16位大于0，说明已经有线程获取写锁了，那么后面的线程获取写锁和读锁都需要排队。如果低16位等于0，说明还没有线程获取写锁，那么线程获取读锁不受影响。</p>
<blockquote>
<p>写锁是可重入的，所以低16位大于0，也可以获取写锁的线程重入次数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">   <span class="comment">//表示移16位</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">   <span class="comment">//1向左移16位，用来得到高16位值</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">   <span class="comment">//读锁的最大并发量</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">   <span class="comment">//写锁的最大并发量，同时也可以得到低16位的值</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//返回同步变量的高16位，读锁的数量</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">   <span class="comment">//返回同步变量的低16位，写锁的数量</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line">   <span class="comment">//记录第一个获取读锁的线程</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">//记录第一个获取读锁的线程重入的次数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line">   <span class="comment">//记录获取读锁的最后一个线程的HoldCounter对象</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line">   <span class="comment">//使用ThreadLocal记录每个线程的HoldCounter信息</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//保存所有线程的获取锁信息</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">            <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//记录线程的获取锁信息</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">         <span class="comment">//重入的次数</span></span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="comment">//线程的id</span></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//构造器</span></span><br><span class="line">   Sync() &#123;</span><br><span class="line">         readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line">         <span class="comment">//保证readHolds的可见性</span></span><br><span class="line">         setState(getState()); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>tryAcquire，获取写锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//获得写锁的线程的重入次数</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="comment">//c不为0</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果当前线程不是获得写锁的线程返回flase</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//如果再重入导致次数大于MAX_COUNT,抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 成功获取锁，更新同步状态</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//c为0，说明还没有线程获取读锁、写锁</span></span><br><span class="line">    <span class="comment">//writerShouldBlock()获取写锁是否阻塞，主要针对公平锁，如果同步队列前面有线程等待，就应该阻塞</span></span><br><span class="line">    <span class="comment">//如果CAS操作失败，也返回false</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//线程成功获取写锁，设置为独占线程</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>tryAcquireShared，获取读锁，需要解决每个读线程的重入次数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//如果写锁已被线程获取，并且不是当前线程，不能获取读锁</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//获取读锁的数量</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="comment">//readerShouldBlock()是否阻塞获取读锁，公平锁模式如果同步队列前面有线程等待直接返回true，非公平锁</span></span><br><span class="line">    <span class="comment">//模式，如果同步队列第一个排队的线程是获取写锁的，并且处于等待状态，则当前线程需要等待阻塞，返回true</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="comment">//成功CAS更新读锁数量</span></span><br><span class="line">        <span class="comment">//如果还没有线程获取读锁，设置当前线程为firstReader，并且重入的次数为1</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">//如果当前线程是firstReader，其重入的次数+1</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果当前线程不是第一个获取读锁，看上一次获取读锁的线程是不是当前线程，如果不是则将当前线程对应</span></span><br><span class="line">            <span class="comment">//的HoldCounter更新为最新的cachedHoldCounter</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="comment">//如果是上一次获取读锁的也是当前线程，且已经释放了，更新readHolds</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            <span class="comment">//当前线程获取读锁次数+1</span></span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果CAS没有成功，循环获取读锁</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>fullTryAcquireShared</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">//如果当前有线程获取了写锁并且不是当前线程，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果获取读锁时应当阻塞</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">//当前线程是第一个获取读锁的线程，不处理</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果上一次获取读锁的线程不是当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            <span class="comment">//阻塞之前需要清空readHolds</span></span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//这里rh.count说明当前读线程是非重入的，第一次尝试没有获取就需要阻塞</span></span><br><span class="line">                <span class="comment">//如果是重入的可以继续循环获取</span></span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//超过读锁最大数量，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">//如果CAS更新读锁数量成功，更新firstReader、cachedHoldCounter、readHolds</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>tryRelease，释放写锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果没有获取写锁，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">//更新state</span></span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>tryReleaseShared，释放读锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//如果当前线程是firstReader，更新firstReaderHoldCount，锁重入的次数</span></span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//如果不是</span></span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="comment">//获得当前线程锁重入的情况，如果小于等于1，删除当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//rh数量减一</span></span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环CAS操作，更新state</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="公平锁-1"><a href="#公平锁-1" class="headerlink" title="公平锁"></a>公平锁</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">//公平锁，就实现读写是否阻塞方法，由于是公平的，所以只要同步队列前面有线程排队，就应该阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="非公平锁-1"><a href="#非公平锁-1" class="headerlink" title="非公平锁"></a>非公平锁</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"> <span class="comment">//非公平锁，由于是非公平的，如果是获取写锁，不需要阻塞直接返回false</span></span><br><span class="line"> <span class="comment">//如果是读锁，第一个排队的是获取写锁的线程，且状态为阻塞等待，当前线程需要阻塞返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="读、写锁"><a href="#读、写锁" class="headerlink" title="读、写锁"></a>读、写锁</h6><p>ReadLock和WriteLock内部类都实现了Lock接口，含有属性Sync对象，lock、unlock等方法调用的是sync的内部方法，核心的获取和释放方法之前都解释了。tryReadLock轮询获取、acquireSharedInterruptibly响应中断获取读锁等就不介绍了，逻辑也不复杂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sync.tryReadLock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">	  <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sync.tryWriteLock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.release(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/max.github.io/2020/05/03/AQS原理解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/max.github.io/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/max.github.io/2020/05/03/AQS原理解析/" itemprop="url">AQS原理解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-03T12:52:03+08:00">
                2020-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/max.github.io/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="AQS原理解析"><a href="#AQS原理解析" class="headerlink" title="AQS原理解析"></a>AQS原理解析</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>AQS(AbstractQueuedSynchronizer)抽象队列同步器，是JUC中很多并发工具的基础框架，比如ReentrantLock、CountDownLatch等，并且线程池ThreadPoolExecutor的worker工作线程类也是基于AQS实现。所以掌握AQS的原理对理解并发工具的原理大有裨益。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>AQS内部有两个重要的内部类，ConditionObject、Node。存在两种队列：条件队列、同步队列。每个队列的节点都是Node对象。只不过条件队列是单链表结构，同步队列是双链表结构。</p>
<ul>
<li><p>条件队列，一般使用condition接口的<code>await</code>方法而阻塞线程封装成节点就先放于条件队列中，如果唤醒后会进入同步队列。</p>
</li>
<li><p>同步队列，尝试获取lock锁（或者说尝试设置AQS原子变量）失败时，线程就会封装成节点放于同步队列。ConditionObject在之前的文章已经分析过了，这里就只分析同步队列了。</p>
</li>
</ul>
<p><img src="/max.github.io/2020/05/03/AQS原理解析/AQS2.png" alt="AQS2"></p>
<p>​                                                                                同步队列示意图</p>
<p>1、第一个线程如果成功获取同步变量后，其它的线程尝试获取会失败，会封装成Node节点，加入到双链表队列中。第一次加入时，链表中没有节点，会生成一个空节点作为Head节点，同时也是Tail节点。然后CAS尝试加入到队尾，成功加入队尾并成为新的Tail节点，同时Head空节点的next指向该封装的Node节点，封装的Node节点的prev也指向Head。然后进入循环尝试一定次数获取同步状态。</p>
<p>2、循环中，如果当前节点前驱节点是Head节点，尝试CAS获取同步状态，成功则将自己设为新的Head节点，清空Thread、prev值，也变成了一个空节点。而原来的Head节点则直接断开，等待GC。</p>
<p>这个过程也说明同步队列是FIFO，先进先出队列。其它复杂的过程就在下面分析。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>AQS继承了AbstractOwnableSynchronizer抽象类，这个类只定义关于<code>exclusiveOwnerThread</code>变量的get、set方法。</p>
<p>原理中说过AQS的数据结构就是内部类Node，封装了尝试获取同步变量的线程和其等待状态。节点有两种类型：独占、共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">AbstractQueuedSynchronizer</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">//标记节点在共享模式下等待</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">//标记节点在独占模式下等待</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取消状态</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//通知状态</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//条件状态</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//传播状态</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">        <span class="comment">//线程等待状态</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">        <span class="comment">//前驱指针</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="comment">//后继指针</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="comment">//包含的线程</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        <span class="comment">//条件队列使用的后继指针</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line">        <span class="comment">//封装成同步队列的节点使用</span></span><br><span class="line">        Node(Thread thread, Node mode) &#123;     </span><br><span class="line">            <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//封装成条件队列的节点使用</span></span><br><span class="line">        Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; </span><br><span class="line">            <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">//AQS的同步队列头节点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">  <span class="comment">//AQS的同步队列尾节点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">  <span class="comment">//AQS的同步状态变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">  <span class="comment">//unfase操作对应的变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> headOffset;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> tailOffset;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> waitStatusOffset;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//unsafe.objectFieldOffset得到的是对象中某字段的内存偏移量，并且可以修改，即使是私有的</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stateOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">"state"</span>));</span><br><span class="line">            headOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">"head"</span>));</span><br><span class="line">            tailOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">"tail"</span>));</span><br><span class="line">            waitStatusOffset = unsafe.objectFieldOffset</span><br><span class="line">                (Node.class.getDeclaredField(<span class="string">"waitStatus"</span>));</span><br><span class="line">            nextOffset = unsafe.objectFieldOffset</span><br><span class="line">                (Node.class.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AQS其实就是线程获取同步变量过程中，封装成节点在同步/条件队列，节点的等待状态的变迁伴随着线程的中断、唤醒、阻塞等。状态变量的解释如下：</p>
<ul>
<li><p>CANCELLED(1)</p>
<p>取消状态，线程因为超时或者中断被取消，这是最终态。</p>
</li>
<li><p>SIGNAL(-1)</p>
<p>通知状态，当前线程在队列的后继线程被阻塞时，如果当前线程获取同步状态释放时或者被取消，需要唤醒后继线程。</p>
</li>
<li><p>CONDITION(-2)</p>
<p>等待状态，处于条件队列的线程的状态。</p>
</li>
<li><p>PROPAGATE(-3)</p>
<p>用于将唤醒的后继线程继续传递下去，一般用于共享锁的唤醒机制。</p>
</li>
<li><p>0</p>
<p>表示无状态。</p>
</li>
</ul>
<h6 id="独占获取"><a href="#独占获取" class="headerlink" title="独占获取"></a>独占获取</h6><p>AQS的独占获取的方法如下：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void acquire(int arg)</td>
<td align="center">获取独占锁</td>
</tr>
<tr>
<td align="center">void acquireInterruptibly(int arg)</td>
<td align="center">响应中断版的jacquire</td>
</tr>
<tr>
<td align="center">tryAcquireNanos(int arg,long nanos)</td>
<td align="center">响应中断、超时版的acquire</td>
</tr>
</tbody></table>
<blockquote>
<p>acquire</p>
</blockquote>
<p>1、tryAcquire()获取同步变量成功，直接退出。否则执行acquireQueued()</p>
<p>2、acquireQueued()将线程封装成一个节点，加入到同步队列尾部，自旋一定次数如果没有获取同步变量会阻塞线程，如     果过程中被中断恢复中断标志，调用selfInterrput()再次中断当前线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tryAcquire()</code>留给子类实现，一般会进行CAS操作compareAndSetState(0, 1)。其实这里运用模板方法设计模式，acquire()方法实现逻辑，内部调用的方法留给子类实现。</p>
<p><code>acquireQueued(addWaiter(Node.EXCLUSIVE),arg)</code>做的事是先创建一个独占模式的Node节点，自旋操作加入到队列尾部。然后自旋操作一定次数尝试获取同步变量，如果需要需要被阻塞，阻塞当前线程，等待被唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个Node节点，封装当前线程</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 如果尾节点不为空，CAS尝试将新的节点设置为尾节点成功，返回</span></span><br><span class="line">    <span class="comment">//否则enq()节点进队列</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自旋，如果初始尾节点为null，CAS创建一个新的空节点作为头尾节点。</span></span><br><span class="line"><span class="comment">//否则，CAS创始将当前线程对应的节点设置为尾节点，直到成功返回。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置操作标志</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//设置中断布尔标志</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        <span class="comment">//1、如果当前节点的前驱节点是头节点，并且当前线程获取同步变量成功，将当前节点设置为新的头节点，消除线         //   程变量和前驱指针变量，原来的头节点分离等待GC。返回中断布尔值。</span></span><br><span class="line">        <span class="comment">//2、否则，判断当前线程是否该阻塞，是则阻塞并判断当前线程是否被中断，如果被中断，设置中断标志为true。</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//会使node.thread=null，node.prev=null</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//如果过程中抛出异常，说明线程要被被取消，执行cancelAcquire()</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>cancelAcquire</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn't exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//将节点的thread置为null</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得当前节点往前的上一个非取消节点</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得pred的next节点，后面CAS会用到</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前节点状态置为CANCELLED</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前节点是尾节点，并且CAS设置pred为新的尾节点成功，CAS设置pred的next节点为空。</span></span><br><span class="line">    <span class="comment">//如果CAS设置尾节点失败了，说明可能有新的节点入队列</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果node还有后继节点，要将pred和后继非取消节点拼接起来</span></span><br><span class="line">        <span class="comment">//如果pred不是头节点，并且状态是SIGNAL或者CAS设置状态为SIGNAL成功，CAS设置pred的next为node.next</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//说明pred为头节点或者pred状态为取消，pred的thread为null</span></span><br><span class="line">            <span class="comment">//这时队列中没有节点获取锁，导致后面的阻塞的线程无法唤醒，需要唤醒当前线程</span></span><br><span class="line">            <span class="comment">//至于pred.next操作没更新，可以留给唤醒线程后的shouldParkAfterFailedAcquire</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里设置node.next=node，而不是null，是为了方便等待队列中isOnSyncQueue方法，如果节点的next不为空</span></span><br><span class="line">        <span class="comment">//说明在同步队列。而对于GC处理，node.next=node和node.next=null是一样的</span></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果当前线程的状态小于0，CAS设置为0</span></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//如果node不为空且状态不为取消，直接唤醒node的下一个节点</span></span><br><span class="line">        <span class="comment">//否则从队尾找，唤醒node最近的一个状态非取消的节点</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>shouldParkAfterFailedAcquire</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">//如果node的前驱节点状态为SIGNAL，在释放锁时会唤醒当前线程。说明可以阻塞自己。</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果前驱节点状态为取消，则往前找上一个非取消的节点作为前驱节点。</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//等待状态为0或者PROPAGATE，CAS设置为SIGNAL，当前线程之后回到循环再次尝试获取锁</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="独占释放"><a href="#独占释放" class="headerlink" title="独占释放"></a>独占释放</h6><p>独占释放的方法如下：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">release(int arg)</td>
<td align="center">释放同步状态</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">//如果头节点不为空，并且状态不为0，唤醒头节点后的状态不为取消的线程</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，release也是模板方法，tryRelease比如会将同步状态设为0。</p>
<h6 id="共享释放"><a href="#共享释放" class="headerlink" title="共享释放"></a>共享释放</h6><p>共享释放锁，比如可重入锁多次获取同步变量后，需要共享释放。</p>
<blockquote>
<p>releaseShared</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tryReleaseShared留给可重入锁实现</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//自旋</span></span><br><span class="line">       <span class="comment">//如果队列不止一个节点，头节点的状态为SIGNAL,CAS设置状态为0，并且唤醒后继节点。</span></span><br><span class="line">       <span class="comment">//如果头节点状态为0，CAS设置状态为PROPAGATE</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="共享获取"><a href="#共享获取" class="headerlink" title="共享获取"></a>共享获取</h6><p>共享获取指多个线程可以同时获取同步变量。</p>
<p><code>tryAcquireShared</code>实现时返回负数表示获取失败，返回0表示获取成功，但后继线程获取不会成功，返回正数表示获取成功，后继线程获取可能成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大部分逻辑和独占相同，主要是获取成功后设置头节点多了设置Propagate。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个共享节点</span></span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置新的头节点还有将新的头节点状态设为PROPAGATE</span></span><br><span class="line"><span class="comment">//这里简单解释下PROPAGETE状态的必要性：（先假设doReleasedShared不会将状态从0设为PROPAGATE）</span></span><br><span class="line"><span class="comment">//假如目前同步队列中有两个共享节点被阻塞，这时进行一次doReleaseShared，会将之前的头节点状态设为0，</span></span><br><span class="line"><span class="comment">//并且唤醒头节点后继线程。然后第一个共享节点被唤醒后成功获取了同步变量。接着再次进行一次doReleaseShared。</span></span><br><span class="line"><span class="comment">//此时第一个节点的线程继续cpu时间片轮转，进行setHeadAndPropagate()。但是此时的头节点仍然是之前的头节点，</span></span><br><span class="line"><span class="comment">//状态为0，不满足进行doReleaseShared的条件，也就不能传播唤醒后继线程，导致线程被挂掉无法唤醒。</span></span><br><span class="line"><span class="comment">//所以需要在doReleasedShared加上head从0设为PROPAGATE的CAS操作，便于传播唤醒。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">        setHead(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>到这AQS的大体都分析完了，可能还有些细节没分析清楚，一些问题有待思考。毕竟AQS的过程还是挺复杂的，之后一定补上遗漏。</p>
<blockquote>
<p>参考  活在夢裡  —— <a href="https://www.cnblogs.com/micrari/p/6937995.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码解读</a>        </p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/max.github.io/2020/05/03/AQS解析之ConditionObject/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/max.github.io/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/max.github.io/2020/05/03/AQS解析之ConditionObject/" itemprop="url">AQS解析之ConditionObject</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-03T12:51:34+08:00">
                2020-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/max.github.io/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="AQS解析之ConditionObject"><a href="#AQS解析之ConditionObject" class="headerlink" title="AQS解析之ConditionObject"></a>AQS解析之ConditionObject</h4><h5 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h5><p>ConditionObject是AQS(AbstractQueuedSynchronizer)抽象队列同步器的一个内部类，实现了JUC(java.util.concurrent)的Condition接口。Condition的await、singnal/singnall和Java的Object类的wait、notify/notifyAll功能类似，阻塞、唤醒线程。使用时，二者都需要获取锁，Object需要Synchronized关键字，Condition需要获取lock锁。相比Object，Condition添加了更多的功能，比如等待响应/不响应中断，等待设置超时时间等。除此之外，一个lock锁，可以对应多个Condition对象，即多个条件队列，在BlockingQueue阻塞队列中，通常需要使用两个条件对象<code>notEmpty</code>、<code>notFull</code> 对应take、put操作。而这两个条件对象就是全局锁ReentrantLock创建的。比如ArrayBlockingQueue构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p><code>Node</code>是AQS另一个内部类，同步队列，每个节点包含一个线程，等待获取锁成功。</p>
<p>同步队列中，<code>Node</code>连接其它节点通过prev、next方式。条件队列中，<code>Node</code>则是通过nextWaiter方式。也意味着同步队列是一个双向链表，条件队列则是单链表。</p>
<p><img src="/max.github.io/2020/05/03/AQS解析之ConditionObject/AQS1.png" alt="AQS1"></p>
<p>​                                                                             条件队列示意图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//条件队列的头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">//条件队列的尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//await时需要重新中断的标志</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REINTERRUPT =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//await时需要抛出中断异常的标志</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THROW_IE    = -<span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>await()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前线程已被中断，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//创建条件队列节点，加入到条件队列尾部</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">//完全释放独占锁，并返回之前的AQS状态变量</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果当前节点不在同步队列上，一直阻塞当前线程，直到如果等待过程中检查中断成功，退出循环。</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//节点进入同步队列后，尝试重新获取独占锁，并且在此过程如果被中断返回true</span></span><br><span class="line">    <span class="comment">//如果之前节点从条件队列转移到同步队列过程中被中断，可能由于被singnal返回REINTERRUPT</span></span><br><span class="line">    <span class="comment">//设置interruptMode为REINTERRUPT</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">//如果当前节点nextWaiter不为空，消除取消状态的节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">//状态为THROW_IE，抛出中断异常，状态为REINTERRUPT，重新中断当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完全释放独占锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获得当前的AQS状态变量</span></span><br><span class="line">            <span class="keyword">int</span> savedState = getState();</span><br><span class="line">            <span class="comment">//如果释放成功，返回之前的状态变量，失败说明没有获得状态监视器时release，抛出异常</span></span><br><span class="line">            <span class="comment">//并且，将当前线程对应的节点置为CANCELLED。</span></span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查当前线程是否已被中断并重置中断标志，如果中断执行transferAfterCancelledWait，否则返回0。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">         (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果CAS设置当前节点状态从CONDITION为0，将节点接到同步队列尾部，返回ture，然后要抛出中断异常</span></span><br><span class="line"><span class="comment">//否则循环等待当前节点在同步队列，原因可能被singnal唤醒，然后返回false，重新要被中断一次</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">            enq(node);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>addConditionWaiter()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// 如果lastWaiter不为空并且状态为CANCELLED取消，删除同步队列中所有状态为取消的节点</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">//删除所有状态为取消的节点</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">//t重新赋值lastWaiter</span></span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//条件队列的节点的状态都是CONDITION，此时还未加入到同步队列</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="comment">//如果队列中节点为空，创建的新节点设为firstWaiter，否则放入lastWaiter后面</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除条件队列中所有状态为取消的节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node t = firstWaiter;</span><br><span class="line">            <span class="comment">//trail保存上一个状态不为取消的节点</span></span><br><span class="line">            Node trail = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//保存下一个节点</span></span><br><span class="line">                Node next = t.nextWaiter;</span><br><span class="line">                <span class="comment">//如果当前节点状态为取消状态</span></span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                    <span class="comment">//断开当前节点</span></span><br><span class="line">                    t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//如果上一个非取消节点未设置，说明头节点状态为取消，next节点作为firstWaiter</span></span><br><span class="line">                    <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                        firstWaiter = next;</span><br><span class="line">                    <span class="comment">//否则将下一个节点链接到trail节点后面，相当于删除了当前节点</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        trail.nextWaiter = next;</span><br><span class="line">                    <span class="comment">//到达尾节点，trail设为lastWaiter</span></span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                        lastWaiter = trail;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    trail = t;</span><br><span class="line">                <span class="comment">//节点后移</span></span><br><span class="line">                t = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>isOnSyncQueue()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查当前节点是否在同步队列</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//同步队列的节点状态不会是CONDITION，prev前驱节点也会存在，否则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//如果有后继节点一定在同步队列，而条件队列一定在队尾</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//有可能node的prev值不为null，但还没在队列中，因为入队列时CAS设置tail失败了，这就需要从tail遍历一次。</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">//从队尾往前遍历，如果相同返回true</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t == node)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            t = t.prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>signal()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前线程没有获得lock锁，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">//获得条件队列的firstWaiter</span></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将节点加入到同步队列，如果失败说明被取消并且后继节点不为空，继续循环。每次失败会使节点从条件队列分离</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">                    lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">                first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                     (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果CAS将节点状态设为0失败，说明节点被取消，这里不会存在竞争，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将当前节点进入同步队列</span></span><br><span class="line">        Node p = enq(node);</span><br><span class="line">        <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">        <span class="comment">//如果当前节点又被取消了或者CAS尝试将改节点状态变为SIGNAL失败可能被取消，唤醒该节点对应的线程重新</span></span><br><span class="line">        <span class="comment">//争锁</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再看下signalAll</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//条件队列头尾节点重置为null</span></span><br><span class="line">    lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//从队头到队尾，尝试将每个节点加入到同步队列</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/max.github.io/2020/04/20/并发工具Excutor框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/max.github.io/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/max.github.io/2020/04/20/并发工具Excutor框架/" itemprop="url">并发工具Excutor框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-20T22:01:25+08:00">
                2020-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/max.github.io/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Excutor框架解析"><a href="#Excutor框架解析" class="headerlink" title="Excutor框架解析"></a>Excutor框架解析</h3><h4 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h4><p>线程的使用提高了程序的执行效率，能同时处理多个任务。在网络编程时，常使用多线程处理客户端的连接，有这样一个需求：当客户端连接请求很多时，如果给每个请求都去主动创建一个线程，就存在以下3个问题：</p>
<ol>
<li>线程生命周期的开销非常高。线程创建时，需要JVM和底层操作系统提供一个辅助操作，尤其当大量线程创建时，创建每个线程时将消耗大量的计算资源。</li>
<li>资源消耗。活跃的线程会消耗系统资源，比如内存，当运行的线程的数量大于可用的cpu核处理器数量，就会有多余的线程处于闲置状态，会占用大量的内存，大量的线程会增大CPU的竞争，产生性能消耗。</li>
<li>稳定性。由于内存的空间有限制，每个线程创建时，需要提供栈空间等，如果线程数量大，可能超出内存大小，抛出OutOfMemory异常。</li>
</ol>
<p>为解决以上问题，就产生了线程池，能够自动帮我们管理线程。主要有3个好处：</p>
<ol>
<li>降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁的损耗。</li>
<li>提高响应速度，当任务到达时，任务可以不需要等待线程创建启动直接执行。</li>
<li>提高线程的可管理性，线程池可以统一对线程进行分配、调优、监控，提高线程的可管理性。</li>
</ol>
<p>Java使用线程池的核心就是Excutor框架，接下来就对这个框架进行分析。</p>
<h4 id="Excutor相关类图"><a href="#Excutor相关类图" class="headerlink" title="Excutor相关类图"></a>Excutor相关类图</h4><p><img src="/max.github.io/2020/04/20/并发工具Excutor框架/Excutor1.png" alt="Excutor1"></p>
<ul>
<li>Executor接口采用了<strong>命令设计模式</strong>，让任务的提交与任务的执行策略解耦开来。</li>
<li>ExecutorService接口扩展了Executor，包含了Excutor的生命周期，以及任务的提交功能。</li>
<li>AbstractExecutorService抽象类使用了newTaskFor方法实现了提交的功能，但submit方法中的execute抽象方法并没有实现，只定义了方法实现逻辑，execute留给子类实现，其实这也是模板方法设计模式，命令设计模式与之结合，可以减少扩展类的规模。</li>
<li>ScheduledExecutorService接口扩展了ExecutorService接口，增加了定时任务执行功能。</li>
<li>ForkJoinPool利用多Cpu的特性，将一个大任务分解成多个小任务，然后同时执行，最后再合并计算结果。</li>
<li>ThreadPoolExecutor线程池核心的实现。</li>
<li>ScheduledThreadPoolExecutor调度线程池的实现。</li>
</ul>
<h4 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Executor &#123;</span><br><span class="line">	 void execute(Runnable command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Executor接口只有一个方法execute，任务是Runnable类。在AbstractExecutorService类中，模板方法submit定义了逻辑，但实现在ThreadPoolExecutor类。</p>
<h5 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface ExecutorService extends Executor &#123;</span><br><span class="line">	 void shutdown();</span><br><span class="line">	 List&lt;Runnable&gt; shutdownNow();</span><br><span class="line">	 boolean isShutdown();</span><br><span class="line">	 boolean isTerminated();</span><br><span class="line">	 boolean awaitTermination(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException;</span><br><span class="line">   &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">   &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">	 Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">	 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        throws InterruptedException;</span><br><span class="line">   &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException;</span><br><span class="line">   &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        throws InterruptedException, ExecutionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Executor以异步方式执行任务，所以在某一时刻，之前提交的任务不是立即完成的，可能处于运行中，可能处于任务队列中，还可能已经完成。关闭的时候，可以”平缓”地关闭，之前提交了的任务继续执行完，但不能再添加新的任务。也可以”粗暴“地关闭，所有任务都停止执行。ExecutorService提供了管理Executor生命周期的方法。</p>
<blockquote>
<p>Executor的生命周期有三种状态：运行、关闭、已终止。</p>
</blockquote>
<p>当Executor创建时就处于运行状态。</p>
<p><code>shutdown()</code>平缓地关闭Executor，不再接受新的任务，同时等待之前提交的任务执行完成，包括还未开始执行的任务。</p>
<p><code>shutdownNow()</code>粗暴地关闭Executor，尝试取消所有运行中的任务，并且不再启动等待队列中的任务，也不接受新的任务。</p>
<p>isShutdown()可以判断Executor是否为关闭状态，至于关闭后，如果有新提交的任务，将由拒绝执行处理器（Rejected Execution Handler）来处理，执行对应的执行策略。等所有任务都完成后，Executor进入终止状态。可以调用awaitTermination()来等待Executor进入等待状态，也可以调用isTerminated来轮询Executor是否为终止状态。</p>
<h5 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h5><p>AbstractExecutorService抽象类实现了ExecutorService部分方法，使用newTaskFor封装任务，实现了submit的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将Runnable和指定结果封装为一个FutureTask任务</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T    value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将Callable封装为一个FutureTask任务</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Runnable任务的提交，没有指定返回结果</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//没有执行结果，RunnableFuture的泛型为Void</span></span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//执行封装的任务，留给子类实现</span></span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带有指定返回结果的Runnable任务提交</span></span><br><span class="line">     <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Callable任务提交</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，任务提交时，都是先将Runnable、Callable任务封装为一个异步任务对象，可以返回任务执行结果的，然后再execute执行任务。并且submit返回这个异步任务对象。可以通过Future的get()方法返回结果，Runnable任务返回结果比较简单，可以立即返回。但是Callable任务不一定能立即返回，需要看任务执行情况，并且get方法会使当前线程阻塞，直到任务执行完成。</p>
<blockquote>
<p>再来看下invokeAll方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//创建一个包含返回结果Future对象的集合</span></span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">    <span class="comment">//定义一个布尔对象，是否完成</span></span><br><span class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//对所有的任务封装成RunnableFuture，加入返回结果集合中，再执行</span></span><br><span class="line">        <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks) &#123;</span><br><span class="line">            RunnableFuture&lt;T&gt; f = newTaskFor(t);</span><br><span class="line">            futures.add(f);</span><br><span class="line">            execute(f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历返回结果Future集合，判断是否任务执行完成，如果没有完成，调用get方法，</span></span><br><span class="line">        <span class="comment">//阻塞当前线程，等待该任务执行完成。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++) &#123;</span><br><span class="line">            Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    f.get();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等所有任务执行完成后，done为true</span></span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> futures;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//如果任务没有都完成，调用cancel()方法尝试取消所有任务</span></span><br><span class="line">        <span class="keyword">if</span> (!done)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">                futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>invokeAll的超时方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                     <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//转化timeout参数</span></span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks)</span><br><span class="line">            futures.add(newTaskFor(t));</span><br><span class="line">        <span class="comment">//得到任务超时的时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanos;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = futures.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依次执行所有任务，预计超时时间减去当前时间，如果小于零即超时了，立即返回当</span></span><br><span class="line">        <span class="comment">//前future集合，但是可能还有任务没有execute执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            execute((Runnable)futures.get(i));</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> futures;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历返回结果future集合，如果任务没有完成，并且执行任务时出现超时使有任务没</span></span><br><span class="line">        <span class="comment">//执行，立即返回future集合。如果没超时，使用get()超时方法，超时时间为之前执</span></span><br><span class="line">        <span class="comment">//行任务剩余的超时时间减去当前时间，并且每次更新</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> futures;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    f.get(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">                    <span class="keyword">return</span> futures;</span><br><span class="line">                &#125;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> futures;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!done)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">                futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><blockquote>
<p>简单分析了Executor相关接口，接下来看下线程池 ThreadPoolExecutor的核心实现</p>
</blockquote>
<h5 id="参数变量"><a href="#参数变量" class="headerlink" title="参数变量"></a>参数变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存任务的阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">    <span class="comment">//全局唯一lock锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//存放工作线程的set集合，每个work工作线程包括一个任务和对应的执行线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line">    <span class="comment">//支持awaitTerminate操作的条件对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line">    <span class="comment">//记录线程池最大的工作线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line">    <span class="comment">//计数器已经完成的任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line">    <span class="comment">//线程工厂，用来创建工作线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line">    <span class="comment">//拒绝策略执行器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line">    <span class="comment">//超时时间，工作线程处于空闲时使用，如果等待工作超过了超时时间，就会标记为可回收。</span></span><br><span class="line">    <span class="comment">//而且如果此时线程池大小超过了集合核心线程数量，这个线程会被立即终止。</span></span><br><span class="line">  	<span class="comment">//可以适当调大这个时间，提高线程的利用率。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line">    <span class="comment">//是否允许使用keepAliveTime超时</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line">    <span class="comment">//线程池的核心数量，默认情况下即时核心线程处于空闲状态也不回收，除非设置allow</span></span><br><span class="line">    <span class="comment">//CoreThreadTimeOut为true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line">    <span class="comment">//线程池能容纳的最大线程数，如果有更多的任务就会执行拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述参数就是线程池的核心参数，几乎构建了线程池的基本运行。除此之外，还有一组状态参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//用来保存线程池的状态，前3位是运行状态，后29位是线程的数量</span><br><span class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">private static final int COUNT_BITS = Integer.SIZE - 3;</span><br><span class="line">//容量为2的29次方减1</span><br><span class="line">private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">// runState is stored in the high-order bits</span><br><span class="line">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int STOP       =  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">// Packing and unpacking ctl</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<p>这里需要了解下计算机怎么存储整数的相关知识。</p>
<blockquote>
<p>学过计算机原理都知道，计算机存储整数都是存储补码的。那为什么不存储原码或者反码呢？</p>
</blockquote>
<p>先解释下原码、反码、补码是什么</p>
<ul>
<li>原码：在数值前面增加了一位符号为，0表示正数，1表示负数，其余位表示数值大小。</li>
<li>反码：正数的反码和原码相同，负数的反码是对其原码逐位取反，但符号位除外。</li>
<li>补码：正数的补码与其原码相同，负数的补码是对该负数的反码加一。0的原反补码相同为00000000。</li>
</ul>
<p>比如2，原码00000010，反码00000010，补码00000010。</p>
<p>比如-2，原码10000010，反码11111101，补码11111110。</p>
<p>如果计算机使用原码，比如1+(-1)=00000001+（10000001）=-2，这是不正确的</p>
<p>如果使用反码，问题出在0上面，0就可以用00000000也可以用（-0）11111111表示，会使0有正负之分。</p>
<p>使用补码就不会出现上述问题。</p>
<blockquote>
<p>再回过来看线程池运行参数</p>
</blockquote>
<p>RUNNING = 1110 0000 0000 0000 , 表示接受新任务并继续处理阻塞队列的任务</p>
<p>SHUTDOWN = 0000 0000 0000 0000,表示不接受新任务，但是继续处理阻塞队列的任务</p>
<p>STOP  = 0010 0000 0000 0000,表示不接受新任务，不继续处理阻塞队列的任务，尝试中断正在执行的任务</p>
<p>TIDYING = 0100 0000 0000 0000,表示所有任务都完成，线程数被回收，等待线程池终止</p>
<p>TERMINATED = 1100 0000 0000 0000,表示线程池处于终止状态</p>
<p>0001 1111 1111 1111</p>
<p>1110000</p>
<h5 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h5><blockquote>
<p>接着看下ThreadPoolExecutor的构造器</p>
</blockquote>
<p>有三种构造器，可以使用默认的线程工厂、拒绝策略执行器，也可以定制它们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认线程工厂，拒绝策略执行器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用定制的线程工厂</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用定制的拒绝策略执行器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断参数的正确性</span></span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//垃圾回收时的参数</span></span><br><span class="line">        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="comment">//线程池的核心参数赋值</span></span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="饱和策略执行器"><a href="#饱和策略执行器" class="headerlink" title="饱和策略执行器"></a>饱和策略执行器</h5><p>拒绝策略也称饱和策略，指队列和线程池都满了，需要一个策略处理新的任务。默认是AbortPolicy，直接抛出异常。总共有四种饱和策略：</p>
<ul>
<li>AbortPolicy，直接抛出异常</li>
<li>DiscardPolicy，不处理直接丢弃掉</li>
<li>CallerRunsPolicy，使用调用者所在的线程执行任务</li>
<li>DiscardOldestPolicy，丢弃队列里最近的一个任务，并执行当前任务。</li>
</ul>
<p>这四种饱和策略执行器，在线程池中是静态内部类实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                             <span class="string">" rejected from "</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h5><p>向线程池中提交任务时，会执行execute方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//ctl.get()原子操作，获得线程池当前状态变量，初始是1110 0000 0000 0000</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//workerCountOf(c)计算的是线程池当前线程数量大小，初始是0</span></span><br><span class="line">    <span class="comment">//小于核心线程池数量，addWorker()创建工作线程执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//isRunning()判断线程池当前是否处于RUNNING运行状态，workQueue.offer()向阻塞队列中提交任务</span></span><br><span class="line">    <span class="comment">//再进行一次运行状态检测，防止线程池状态发生变化，并且线程池关闭，使用饱和策略执行任务</span></span><br><span class="line">    <span class="comment">//否则，如果当前工作线程数量为0，addWorker()创建一个不包含任务的非核心工作线程，只要创建了工作</span></span><br><span class="line">    <span class="comment">//线程，就能从阻塞队列中取出任务执行</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果阻塞队列任务满了，addWorker创建非核心工作线程执行任务</span></span><br><span class="line">    <span class="comment">//如果当前线程数大于maximumPoll,则执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>到这里可以完整地介绍下线程池的运行原理</p>
</blockquote>
<p><img src="/max.github.io/2020/04/20/并发工具Excutor框架/%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7Excutor%E6%A1%86%E6%9E%B6%5CExcutor2.png" alt="Excutor2"></p>
<p><code>execute()</code>向线程池中提交任务时</p>
<ol>
<li>如果当前工作线程数量小于corePoolSize核心线程数量，需要创建新的工作线程执行任务。</li>
<li>如果当前工作线程数量等于大于corePoolSize，加入到阻塞队列BlockingQueue中。每次创建工作线程时，都会尝试从阻塞队列中获取任务。</li>
<li>如果阻塞队列满了，则创建新的非核心工作线程执行任务。</li>
<li>如果当前工作线程数量大于maximumPoolSize线程池工作线程的最大值，则使用RejectedExcutionHandler拒绝策略执行器处理这个任务。</li>
</ol>
<h5 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h5><p>在<code>execute()</code>中，创建工作线程时使用addWorker()，addWorker(Runnable firstTask, boolean core)，有两个参数，第一个参数是执行的任务，第二个参数是是否为核心线程，true代表创建核心线程，false代表创建非核心线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">//循环处理，直到CAS操作成功增加工作线程</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//c是线程池的状态变量，rs是线程池的运行状态</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果运行状态大于等于SHUTDOWN,即stop、tidying、terminated时，这是第一个条件</span></span><br><span class="line">        <span class="comment">// 第二个条件，如果运行状态大于SHUTDOWN，返回false。</span></span><br><span class="line">        <span class="comment">// 如果运行状态是SHUTDOWN,并且firstTask任务为空，即创建一个空任务的线程从阻塞队列获取任务，</span></span><br><span class="line">        <span class="comment">// 但是如果阻塞队列的任务也为空，即返回false，也没有必要创建线程。</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			 <span class="comment">//状态条件判断完成后，进行CAS增加线程数量</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">//如果大于最大容量或者创建核心线程时，大于核心线程数量，创建非核心线程时，大于最大数量</span></span><br><span class="line">            <span class="comment">//返回false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//CAS线程数量后的操作，真正创建线程</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//工作线程对象</span></span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//new一个工作线程对象，传递任务对象</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="comment">//获取全局唯一lock锁</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取线程池运行状态</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">//如果是RUNNING,或者创建一个空的任务的线程</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">//检查线程是否是活跃的</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) </span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">//向包含工作线程集合中添加线程对象</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">//如果已经创建出的线程大于largestPoolSize，更新值</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    <span class="comment">//成功添加</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果成功添加，工作线程启动，执行任务，任务成功启动</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//如果任务没有成功启动，从works集合删除这个线程对象，并且CAS线程数量减一</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先进行线程池状态变量的判断，如果运行状态大于等于SHUTDOWN,并且阻塞队列的任务为空时，就返回false。然后进行CAS操作，对线程数量增1。</p>
<p>接着进行创建工作线程，如果是RUNNING状态或者是SHUTDOWN状态且任务为空时，启动线程。如果线程启动失败，执行addWorkerFailed操作。</p>
<blockquote>
<p>至此，execute涉及的操作都差不多分析完了，接下来看下Work工作线程内部类。</p>
</blockquote>
<h5 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">       <span class="comment">// 工作线程对象</span></span><br><span class="line">       <span class="keyword">final</span> Thread thread;</span><br><span class="line">       <span class="comment">//执行的任务对象</span></span><br><span class="line">       Runnable firstTask;</span><br><span class="line">       <span class="comment">//已经完成的任务计数器</span></span><br><span class="line">       <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">         Worker(Runnable firstTask) &#123;</span><br><span class="line">            <span class="comment">//AQS设置状态</span></span><br><span class="line">            setState(-<span class="number">1</span>); </span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="comment">//使用线程工厂创建线程</span></span><br><span class="line">            <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runWorker(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">     ...... </span><br><span class="line">     <span class="comment">//其它重写AQS的方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个问题，为什么不直接在execute创建线程，而是封装成Worker？</p>
<p>其实是为了更好地解决中断，使用AQS实现，当运行时上锁就不能中断。</p>
<blockquote>
<p>runWorker()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//new Worker()时，state=-1，此时unlock()是调用tryRelease()方法，将state置0，在interruptIfSta</span></span><br><span class="line">    <span class="comment">//rted（）中只有state&gt;=0,才允许中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果当前任务不为空或者从阻塞队列中获取到了任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//工作线程获取lock锁，不是为了防止并发任务，是为了线程池的shutdown()时不终止正在运行</span></span><br><span class="line">            <span class="comment">//的worker线程</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">//线程池状态&gt;STOP时，且当前线程没有设置中断标志，当前线程中断</span></span><br><span class="line">            <span class="comment">//如果一开始线程池状态小于STOP时，当前线程但是当前线程已被中断，但又清除了中断标志，</span></span><br><span class="line">            <span class="comment">//再次判断线程池状态是否是大于等于STOP,如果是当前线程中断</span></span><br><span class="line">            <span class="comment">//如果不是，不做操作，此时中断位已经被清除了</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                <span class="comment">//判断中断位是否清除</span></span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                <span class="comment">//当前线程中断</span></span><br><span class="line">                wt.interrupt();  </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行前的操作，留给子类实现</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//执行任务</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//处理worker线程的退出</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里涉及到getTask()，再看下getTask()获取任务的实现</p>
<blockquote>
<p>getTask()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">    <span class="comment">//循环操作</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取线程池状态变量和运行状态参数</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果运行状态大于等于SHUTDOWN，并且大于等于STOP或者阻塞队列为空</span></span><br><span class="line">        <span class="comment">//CAS线程数量减一，即阻塞队列没有任务</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是非核心线程或者允许了线程空闲超时，timed为true</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果当前线程数量大于maximumPoolSize或者设置了定时超时</span></span><br><span class="line">        <span class="comment">//并且阻塞队列中没有任务或者当前仍有工作线程，CAS操作减一线程数量，减一次就行</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果定时了，则从阻塞队列中超时获取任务，如果没定时，则直接teke操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">//没有返回说明超时，进行下一次循环，每次工作线程数量都减一</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">//发生中断，将timeOut为false</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/max.github.io/2020/04/13/并发工具——阻塞队列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/max.github.io/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/max.github.io/2020/04/13/并发工具——阻塞队列/" itemprop="url">并发工具——阻塞队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-13T18:54:56+08:00">
                2020-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/max.github.io/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="并发工具——阻塞队列"><a href="#并发工具——阻塞队列" class="headerlink" title="并发工具——阻塞队列"></a>并发工具——阻塞队列</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>并发编程中使用生产者——消费者模式可以解决大多数并发的问题，在这种模式下，通过平衡生产者线程生产数据和消费者线程消费数据的速度，可以提高程序整体处理数据的速度。怎么平衡呢？就是阻塞队列当作缓冲区，生产者生产完数据直接放到阻塞队列中，等待消费者从中拿取数据。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>阻塞队列充当了一个缓冲区，生产者线程不断向队列中添加元素，消费者线程不断从队列中拿取元素。由于队列容量是有限的，当队列已满，生产者线程就会被阻塞，必须等消费者线程获取一个元素才能被唤醒。当队列为空，消费者线程就会被阻塞，必须等生产者线程放入队列元素才能被唤醒。</p>
<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><p>BlockingQueue接口继承关系如下</p>
<p><img src="/max.github.io/2020/04/13/并发工具——阻塞队列/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%971.png" alt="阻塞队列1"></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">抛出异常</th>
<th align="center">特殊值</th>
<th align="center">阻塞</th>
<th align="center">超时</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入</td>
<td align="center">add(E e)</td>
<td align="center">offer(E e)</td>
<td align="center">put(E e)</td>
<td align="center">offer(E e, long timeout, TimeUnit unit)</td>
</tr>
<tr>
<td align="center">移除</td>
<td align="center">remove(E e)</td>
<td align="center">poll()</td>
<td align="center">take()</td>
<td align="center">poll(long timeout, TimeUnit unit)</td>
</tr>
<tr>
<td align="center">返回</td>
<td align="center">element()，返回队首元素</td>
<td align="center">peek()</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li><p>抛出异常：当队列满时，再向队列插入元素会抛出异常，队列为空，从队列获取元素会抛出异常。</p>
</li>
<li><p>特殊值：往队列中插入元素时，如果插入成功返回true。从队列中取元素，如果没有返回null。</p>
</li>
<li><p>阻塞：当阻塞队列满时，如果生产者线程往队列中put元素，队列会阻塞生产者线程，直到队列可用或者响应中断退出。当队列为空，消费者take元素，队列会阻塞消费者线程，直到队列可用。</p>
</li>
<li><p>超时：队列满时或为空，队列阻塞线程，如果超过了一定时间，线程会自动退出。</p>
</li>
</ul>
<h5 id="常用的阻塞队列"><a href="#常用的阻塞队列" class="headerlink" title="常用的阻塞队列"></a>常用的阻塞队列</h5><table>
<thead>
<tr>
<th align="center">队列</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ArrayBlockingQueue</td>
<td align="center">一个由数组结构组成的有界阻塞队列</td>
</tr>
<tr>
<td align="center">LinkedBlockingQueue</td>
<td align="center">一个由链表结构组成的有界阻塞队列</td>
</tr>
<tr>
<td align="center">PriorityBlockingQueue</td>
<td align="center">一个支持优先级排序的无界阻塞队列</td>
</tr>
<tr>
<td align="center">DelayQueue</td>
<td align="center">一个使用优先级队列实现的无界阻塞队列</td>
</tr>
<tr>
<td align="center">SynchronousQueue</td>
<td align="center">一个不存储元素的阻塞队列</td>
</tr>
<tr>
<td align="center">LinkedTransferQueue</td>
<td align="center">一个由链表结构组成的无界阻塞队列</td>
</tr>
<tr>
<td align="center">LinkedBlockingDeque</td>
<td align="center">一个由链表结构组成的双向阻塞队列</td>
</tr>
</tbody></table>
<h6 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h6><p>ArrayBlockingQueue是由数组实现的阻塞队列，看下包含的字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承了AbstractQueue，实现序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//保存队列元素的数组</span></span><br><span class="line">		<span class="keyword">final</span> Object[] items;</span><br><span class="line">		<span class="comment">//下一次take元素的索引</span></span><br><span class="line">		<span class="keyword">int</span> takeIndex;</span><br><span class="line">		<span class="comment">//下一次put元素的索引</span></span><br><span class="line"> 		<span class="keyword">int</span> putIndex;</span><br><span class="line"> 		<span class="comment">//队列中元素的数量</span></span><br><span class="line">		<span class="keyword">int</span> count;</span><br><span class="line">	  <span class="comment">//唯一可重入锁</span></span><br><span class="line">		<span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="comment">//用来阻塞take操作</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    <span class="comment">//用来阻塞put操作</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>看下构造函数</li>
</ul>
<p>构造函数有三种，ArrayBlockingQueue(int )、ArrayBlockingQueue(int, boolean)、 ArrayBlockingQueue(int , boolean,  Collection&lt;? extends E&gt; )。默认fair为false，代表非公平锁模式。</p>
<p>公平锁模式就是当线程退出阻塞时，先被阻塞的线程先访问队列。非公平锁模式是阻塞的线程可以随机竞争访问阻塞队列，提高了吞吐率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加元素操作，add、offer</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//在队列尾部添加元素，队列满时抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//先加锁，再添加。队列满时返回false。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      checkNotNull(e);</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (count == items.length)</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              enqueue(e);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">      <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">      <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">      <span class="comment">//数组尾部添加元素</span></span><br><span class="line">      items[putIndex] = x;</span><br><span class="line">      <span class="comment">//如果添加元素满了，putIndex设为0</span></span><br><span class="line">      <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">          putIndex = <span class="number">0</span>;</span><br><span class="line">      count++;</span><br><span class="line">      <span class="comment">//如果take操作线程被阻塞，condition唤醒进行take操作的线程</span></span><br><span class="line">      notEmpty.signal();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>put操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//线程被中断时会抛出异常</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="comment">//队列的元素如果已经满了，put操作对应的condition会阻塞当前线程，等待被take操作的线程唤醒</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">      	<span class="comment">//唤醒后进行enqueue()</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>take操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">      <span class="comment">//线程被中断会抛出异常</span></span><br><span class="line">      lock.lockInterruptibly();</span><br><span class="line">      <span class="comment">//当前队列元素为空时，take操作对应的condition会阻塞当前线程，等待被offer、put操作的线程唤醒</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">              notEmpty.await();</span><br><span class="line">        	<span class="comment">//获取元素并返回</span></span><br><span class="line">         <span class="keyword">return</span> dequeue();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">      <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">      <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      <span class="comment">//获取元素并赋值</span></span><br><span class="line">      E x = (E) items[takeIndex];</span><br><span class="line">      <span class="comment">//将原来的位置赋为空</span></span><br><span class="line">      items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//如果元素都已经获取完了，takeIndex设为空</span></span><br><span class="line">    	<span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">          takeIndex = <span class="number">0</span>;</span><br><span class="line">      count--;</span><br><span class="line">      <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">          itrs.elementDequeued();</span><br><span class="line">      <span class="comment">//唤醒put操作对应的线程</span></span><br><span class="line">      notFull.signal();</span><br><span class="line">      <span class="keyword">return</span> x;	</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>总结</li>
</ul>
<ol>
<li>初始化阻塞队列，构造器默认可重入锁是非公平性的。</li>
<li>一个线程进行put操作，如果队列的元素已经满了，put操作的condition对象会阻塞该线程。等待进行take操作的其他线程，获取元素然后唤醒该线程。同理，进行take操作，如果队列的元素为空，take操作的condition对象会阻塞线程，等待被put操作的其它线程唤醒。</li>
</ol>
<h6 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h6><p>LinkedBlockingQueue是基于链表构成的有界的阻塞队列。</p>
<ul>
<li>看下字段属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//链表的最大长度</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当前的元素数量，原子计数器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//链表的头节点</span></span><br><span class="line">	<span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//链表的尾节点</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//take、poll操作对应的lock锁</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//阻塞take操作的condition对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//put、offer操作对应的lock锁</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//阻塞put操作的condition对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//内部类Node，链表的元素</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">			 <span class="comment">//链表元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">//下一个链表元素</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node(E x) &#123; item = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>看下构造器</p>
<p>三种构造器，LinkedBlockingQueue()、LinkedBlockingQueue(Collection&lt;? extends E&gt; )、        LinkedBlockingQueue(int )，默认capacity是Integer.MAX_VALUE（2^31^-1）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//设置元素容量</span></span><br><span class="line">  	<span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    <span class="comment">//初始化头、尾节点，元素为空</span></span><br><span class="line">  	last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="comment">//获取put操作对应的lock锁</span></span><br><span class="line">  	putLock.lock(); <span class="comment">// Never contended, but necessary for visibility</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (n == capacity)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">            enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//原子操作设置元素的数量</span></span><br><span class="line">        count.set(n);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>put操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></span><br><span class="line">    <span class="comment">// holding count negative to indicate failure unless set.</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//创建一个节点，包含要添加的元素</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">//获取put操作对应lock锁，可响应中断</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//如果当前元素数量等于链表最大长度，put操作对应的condition阻塞当前线程，等待take操作线程唤醒</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//元素添加到链表尾部</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">//原子操作进行元素数量加一，并且返回当前元素数量</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">//如果还可以再添加元素，put操作对应的condition唤醒被put操作阻塞的线程</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果原来的链表为空，现在刚添加元素，则唤醒被take操作阻塞的线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取take操作对应的锁，take操作对应的condition对象唤醒被take操作阻塞的线程</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">        takeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//链表的尾部添加元素，并赋为新的尾节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">        <span class="comment">// assert last.next == null;</span></span><br><span class="line">        last = last.next = node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>take操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    <span class="comment">//获取take操作对应的lock锁，可响应中断</span></span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//如果当前链表元素为空，take操作对应的condition阻塞当前线程，等待put操作进行操作直到元素满时</span></span><br><span class="line">       <span class="comment">//唤醒当前线程</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移除链表头部第一个元素</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="comment">//如果现在链表还有元素，take操作对应的condition唤醒被take操作阻塞的线程</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果操作之前的链表元素满时，put操作对应的condition唤醒被put操作阻塞的线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">        <span class="comment">// assert head.item == null;</span></span><br><span class="line">        <span class="comment">//获取链表头节点</span></span><br><span class="line">        Node&lt;E&gt; h = head;</span><br><span class="line">        <span class="comment">//获取链表头节点的第一个元素并保存</span></span><br><span class="line">        Node&lt;E&gt; first = h.next;</span><br><span class="line">        <span class="comment">//将原来的head节点next指向自己</span></span><br><span class="line">        h.next = h; <span class="comment">// help GC</span></span><br><span class="line">        <span class="comment">//head重新指向保存的下一个节点，原来的head节点会被GC</span></span><br><span class="line">        head = first;</span><br><span class="line">        E x = first.item;</span><br><span class="line">        <span class="comment">//新的head头节点元素设为null</span></span><br><span class="line">        first.item = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//返回head节点的第一个元素</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">        putLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notFull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            putLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h6><p>PriorityBlockingQueue阻塞队列是具有优先级顺序的无界特点，优先级表现是元素需要实现Comparable接口，比较结果小的元素排在队列前面。无界表现在队列可以扩容很大，最大可以扩容到Integer    .MAX_VALUE-8(2^31^-9)。队列元素出队和DelayQueue一样，基于PriorityQueue实现，从队头出列，并且元素重新构成最小堆。</p>
<ul>
<li>字段属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">     <span class="comment">//队列元素默认数量</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line">     <span class="comment">//队列扩容的最大数量</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">     <span class="comment">//底层真正保存元素的数组</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue; </span><br><span class="line">     <span class="comment">//队列元素的数量</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size; </span><br><span class="line">     <span class="comment">//队列元素排序的指定比较器</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">     <span class="comment">//唯一可重入锁</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">     <span class="comment">//阻塞take操作的条件对象</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">     <span class="comment">//take操作的CAS锁</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> allocationSpinLock;</span><br><span class="line">     <span class="comment">//序列化操作使用</span></span><br><span class="line">     <span class="keyword">private</span> PriorityQueue&lt;E&gt; q;</span><br><span class="line">     <span class="comment">//UNSAFE类，用来构建CAS操作</span></span><br><span class="line">     <span class="comment">// Unsafe mechanics</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> allocationSpinLockOffset;</span><br><span class="line">     <span class="comment">//static静态块初始时，UNSAFE.objectFieldOffset方法转化allocationSpinLock字段</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = PriorityBlockingQueue.class;</span><br><span class="line">            allocationSpinLockOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"allocationSpinLock"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  	</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造器传入默认容量，比较器为null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入自定义comparator比较器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">        <span class="comment">//队列数组初始化</span></span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>put操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    offer(e); <span class="comment">// never need to block</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">//获取lock锁</span></span><br><span class="line">  			lock.lock();</span><br><span class="line">        <span class="comment">//定义队列size、capacity、array数组局部变量</span></span><br><span class="line">  			<span class="keyword">int</span> n, cap;</span><br><span class="line">        Object[] array;</span><br><span class="line">  			<span class="comment">//先对局部变量赋值，如果当前size大于等于array的长度，进入扩容，传入array、cap变量</span></span><br><span class="line">        <span class="keyword">while</span> ((n = size) &gt;= (cap = (array = queue).length))</span><br><span class="line">            tryGrow(array, cap);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">            <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">              	<span class="comment">//使用最小堆的“上沉操作”，将元素插入到正确的位置</span></span><br><span class="line">                siftUpComparable(n, e, array);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                siftUpUsingComparator(n, e, array, cmp);</span><br><span class="line">            size = n + <span class="number">1</span>;</span><br><span class="line">          	<span class="comment">//唤醒take操作处于等待队列的线程</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>看下tryGrow扩容操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryGrow</span><span class="params">(Object[] array, <span class="keyword">int</span> oldCap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//因为offer操作中先加了锁，扩容时没必要上锁，所以释放锁</span></span><br><span class="line">  	lock.unlock(); <span class="comment">// must release and then re-acquire main lock</span></span><br><span class="line">    <span class="comment">//定义局部变量新的数组</span></span><br><span class="line">  	Object[] newArray = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//使用CAS操作，只有一个线程能成功进行扩容</span></span><br><span class="line">  	<span class="keyword">if</span> (allocationSpinLock == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, allocationSpinLockOffset,</span><br><span class="line">                                 <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">//如果旧容量小于64，新容量扩增一倍</span></span><br><span class="line">          	<span class="comment">//如果旧容量大于64，新容量扩增1/2</span></span><br><span class="line">            <span class="keyword">int</span> newCap = oldCap + ((oldCap &lt; <span class="number">64</span>) ?</span><br><span class="line">                                   (oldCap + <span class="number">2</span>) : <span class="comment">// grow faster if small</span></span><br><span class="line">                                   (oldCap &gt;&gt; <span class="number">1</span>));</span><br><span class="line">            <span class="comment">//新容量如果大于2的31次方-9，判断如果旧容量+1大于这个值，抛出异常</span></span><br><span class="line">          	<span class="comment">//否则新容量为这个值</span></span><br><span class="line">          	<span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;    <span class="comment">// possible overflow</span></span><br><span class="line">                <span class="keyword">int</span> minCap = oldCap + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (minCap &lt; <span class="number">0</span> || minCap &gt; MAX_ARRAY_SIZE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">                newCap = MAX_ARRAY_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//注意queue==array，如果扩容过程中数组被修改了，被其它线程成功扩容，本线程扩容就失败了</span></span><br><span class="line">            <span class="keyword">if</span> (newCap &gt; oldCap &amp;&amp; queue == array)</span><br><span class="line">                newArray = <span class="keyword">new</span> Object[newCap];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//CAS变量重置为0</span></span><br><span class="line">            allocationSpinLock = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//如果扩容失败，该线程主动退出CPU调度</span></span><br><span class="line">    <span class="keyword">if</span> (newArray == <span class="keyword">null</span>) <span class="comment">// back off if another thread is allocating</span></span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="comment">//重新获取lock锁</span></span><br><span class="line">  	lock.lock();</span><br><span class="line">  	<span class="comment">//如果成功扩容，复制数据到新的数组</span></span><br><span class="line">    <span class="keyword">if</span> (newArray != <span class="keyword">null</span> &amp;&amp; queue == array) &#123;</span><br><span class="line">        queue = newArray;</span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, oldCap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>take操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//获取lock锁，可响应中断</span></span><br><span class="line">  	lock.lockInterruptibly();</span><br><span class="line">    E result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//如果队列中元素为空，当前线程进入等待队列</span></span><br><span class="line">        <span class="keyword">while</span> ( (result = dequeue()) == <span class="keyword">null</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素出队</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] array = queue;</span><br><span class="line">            <span class="comment">//返回队列头部元素</span></span><br><span class="line">          	E result = (E) array[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//将队尾元素移至队首，然后队尾置空</span></span><br><span class="line">          	E x = (E) array[n];</span><br><span class="line">            array[n] = <span class="keyword">null</span>;</span><br><span class="line">            Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">            <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">              	<span class="comment">//最小堆的“下沉操作”，将队尾元素下沉到正确的位置</span></span><br><span class="line">                siftDownComparable(<span class="number">0</span>, x, array, n);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                siftDownUsingComparator(<span class="number">0</span>, x, array, n, cmp);</span><br><span class="line">            size = n;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h6><p>DelayQueue阻塞队列是基于PriorityQueue优先级队列形成的，元素的数量没有限制，所以是无边界的。其次，DelayQueue队列的元素必须实现Delayed接口。延时越小的元素放在队列前面，take操作每次也从队首取出元素。</p>
<ul>
<li>字段属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">		<span class="comment">//操作需要获取的lock锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//真正保存元素的优先级队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line">    <span class="comment">//leader线程是当前进行take操作的线程，如果队首元素延时没有到，该线程成为leader线程</span></span><br><span class="line">    <span class="comment">//等该线程take操作完后，lead为null，其它的take操作线程竞争成为新的leader线程</span></span><br><span class="line"> 		<span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//用来等待不能进行take操作的线程，可能元素延时未到或者当前线程不是leader线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>PriorityQueue的元素放置顺序是由其实现的compareTo方法实现的，排序越小的元素放到队列前面，所以如果排序方法不对，会使延时过期时间长的元素比过期时间短的元素排到更前面，延时低的元素无法出队。    </p>
</blockquote>
<ul>
<li><p>构造器</p>
<p>public DelayQueue(){}、 public DelayQueue(Collection&lt;? extends E&gt; c){…}</p>
</li>
</ul>
<p>构造器只有两种，没有赋值操作</p>
<ul>
<li>take操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//获取lock锁，可响应中断</span></span><br><span class="line">  	lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//循环处理</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          	<span class="comment">//获取队列首元素</span></span><br><span class="line">            E first = q.peek();</span><br><span class="line">          	<span class="comment">//如果队列还没有元素被添加，当前线程释放锁，进入等待队列</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">//getDelay(NANOSECONDS）判断当前时间元素是否过期</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">              	<span class="comment">//如果过期，则进行poll()操作，然后返回队首元素</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">              	<span class="comment">//等待时候，first设为null</span></span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="comment">//如果leader线程不为空，则当前线程释放锁，进入等待队列</span></span><br><span class="line">              	<span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//如果leader线程为空，说明没有take操作的线程竞争称为leader线程，当前线程</span></span><br><span class="line">                  <span class="comment">//成为leader线程</span></span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                      	<span class="comment">//等待剩余的过期时间，当前leader线程释放锁，进入等待队列</span></span><br><span class="line">                      	<span class="comment">//直到当前线程再次获取到锁的过程中，其它线程获得了锁，但是不是leader</span></span><br><span class="line">                      	<span class="comment">//线程，也还会释放锁，进入等待队列</span></span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                      	<span class="comment">//当前leader线程成功获取锁后，leader线程设置为null</span></span><br><span class="line">                      	<span class="comment">//进入下一个循环，返回队首元素</span></span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      	<span class="comment">//当前线程成功进行完take操作后，如果队列还有元素，唤醒等待队列中的线程进行take操作</span></span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">      	<span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>put操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//获取lock锁</span></span><br><span class="line">  	lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//调用的是priotityqueue的offer()方法</span></span><br><span class="line">        q.offer(e);</span><br><span class="line">      	<span class="comment">//如果插入的元素刚好位于队首，将leader线程置为null，唤醒等待队列中的线程，进行take操作</span></span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            available.signal();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>先介绍以上四种常见的阻塞队列，主要阻塞队列的种类和各自的特点比较多杂，剩余的三种之后再介绍吧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/max.github.io/2020/04/06/netty集群的一次实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/max.github.io/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/max.github.io/2020/04/06/netty集群的一次实践/" itemprop="url">netty集群的一次实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-06T13:03:30+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/max.github.io/categories/netty/" itemprop="url" rel="index">
                    <span itemprop="name">netty</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="netty集群的一次实践"><a href="#netty集群的一次实践" class="headerlink" title="netty集群的一次实践"></a>netty集群的一次实践</h4><h6 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h6><p>我们使用netty时，一般只设计一个服务端节点。这样也没什么问题，单机环境下netty最大可支撑1w左右客户端长连接，但是如果有更多的客户端连接需求，单机就满足不了了。可以采用netty集群的方案解决，集群的意思就是多个服务器部署相同的netty服务，增大客户端连接数量。那怎么管理这些服务端节点，怎么让客户端均衡地获得服务器资源，可以使用zookeeper解决。</p>
<blockquote>
<p>zookeeper在dubbo中用来管理注册服务和提供服务。那么在这里我们也需要实现服务注册、提供、发现，还要解决一个负载均衡的问题。</p>
</blockquote>
<h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><p>1、服务注册</p>
<p>netty的服务注册，就是netty启动时将服务器的ip、port作为一个ZNode注册到zookeeper中，ZNode就是zookeeper中数据的最小单元。每个节点可以存储数据，也可以挂载子节点，构成一个树。如下图所示：</p>
<p><img src="/max.github.io/2020/04/06/netty集群的一次实践/first.png" alt="first"></p>
<p>zookeeper访问每个节点 是按照路径访问，类似Unix的文件系统。</p>
<p>注册生成的节点有四种类型</p>
<blockquote>
<p>持久节点PRESISTENT</p>
</blockquote>
<p>持久节点生成后，就会一直存在zookeeper服务器中，直到有删除操作主动删除。</p>
<blockquote>
<p>临时节点EPHEMERAL</p>
</blockquote>
<p>临时节点会在客户端和zookeeper服务器会话断开时自动删除，其中zookeeper规定了不能基于临时节点创建子节点，只能作为叶子节点。</p>
<p>这里要注意一个问题：如果消费者不断地去连接之前订阅的服务节点的过程中，这个节点如果是持久节点，当提供这个服务节点的提供者因为宕机对外不能提供服务，但是zookeeper并不会删除这个节点，导致仍有消费者不断连接这个服务节点，就会出现错误。所以这种情况下作为临时节点，如果消费者订阅的节点出现异常，就会通知消费者，进而进行其它处理。</p>
<blockquote>
<p>持久顺序节点PERSISTENT_SEQUENTIAL</p>
</blockquote>
<p>在持久节点基础上，会额外为每一个父节点的第一级子节点维护创建顺序。</p>
<blockquote>
<p>临时顺序节点EPHEMERAL_SEQUENTIAL</p>
</blockquote>
<p>在临时节点基础上，也增加了顺序的特性。</p>
<p>先创建一个根节点，然后将ip、port作为一个子节点，根节点类型是持久节点，子节点类型是临时节点。</p>
<p>使用Java的ZKClient类实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//创建根节点</span><br><span class="line">public void createRootNode()&#123;</span><br><span class="line">        boolean exists = zkClient.exists(&quot;/root&quot;);</span><br><span class="line">        if (exists)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;	</span><br><span class="line"></span><br><span class="line">        //创建 root</span><br><span class="line">        zkClient.createPersistent(&quot;/root&quot;) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建子节点</span><br><span class="line"> public void createNode(String path) &#123;</span><br><span class="line">        zkClient.createEphemeral(path);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public void RegisterZK()&#123;</span><br><span class="line">   	createRootNode();</span><br><span class="line">   	//本机ip</span><br><span class="line">   	String ip = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">   	String path =&quot;/root&quot;+ +&quot;/&quot;+ip+&quot;:&quot;+&quot;8088&quot;;</span><br><span class="line">   	</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>2、服务提供</p>
<p>客户端每次怎么发现服务器的节点列表，怎么把注册的服务提供客户端。</p>
<ul>
<li>每次都到zookeeper中查询，显然这种效率太低。</li>
<li>本地使用一个缓存列表保存zookeeper的可用服务节点，并且zookeeper的节点发生变更，本地的缓存列表也需要变更。</li>
</ul>
<p>使用缓存列表的方式相较更合理些。</p>
<p>使用<code>com.google.common.cache</code>包的LoadingCache类作为缓存列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public CacheUtil&#123;</span><br><span class="line">		</span><br><span class="line">		 @Autowired</span><br><span class="line">	   private LoadingCache&lt;String, String&gt; cache;</span><br><span class="line">  	 	</span><br><span class="line">  	 public void addCache(String key) &#123;</span><br><span class="line">        cache.put(key, key);</span><br><span class="line">     &#125;</span><br><span class="line">    	</span><br><span class="line">     //更新缓存时，先删除再增加 </span><br><span class="line">     public void updateCache(List&lt;String&gt; nodeList) &#123;</span><br><span class="line">        cache.invalidateAll();</span><br><span class="line">        for (String node : nodeList) &#123;</span><br><span class="line">            addCache(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //获取所有节点</span><br><span class="line">		public List&lt;String&gt; getAll() &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">			 if (cache.size() == 0) &#123;</span><br><span class="line">            List&lt;String&gt; allNode = zkClient.getChildren(&quot;/root&quot;);</span><br><span class="line">            for (String node : allNode) &#123;</span><br><span class="line">                addCache(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (Map.Entry&lt;String, String&gt; entry : cache.asMap().entrySet()) &#123;</span><br><span class="line">            list.add(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、服务订阅</p>
<p>上面使用一个缓存列表来保存zookeeper中注册的可用服务节点，并且注册的节点的变更也会同步到缓存列表中。怎么保证同步的？或者说客户端怎么订阅zookeeper的服务？</p>
<p>zookeeper提供了一个Watcher机制，实现当客户端订阅的服务状态发生变化，zookeeper会自动通知客户端。</p>
<p><img src="/max.github.io/2020/04/06/netty集群的一次实践/two.png" alt="two"></p>
<p>Watcher机制如上图所示</p>
<ul>
<li>客户端向zookeeper注册Watcher</li>
<li>Watcher对象会存储在客户端的WatchManager中</li>
<li>当zookeeper触发Watcher事件后，会向 客户端发送通知，客户端从WatcheManager中取出对应的Watcher对象来执行回调逻辑</li>
</ul>
<blockquote>
<p>这里需要注意的是：当节点发生变更时，zookeeper的watcher只会通知客户端数据节点发生变更，而节点的原始数据和变更后的数据是无法从通知事件中得到的，需要客户端重新主动从zookeeper中获取。</p>
</blockquote>
<p>其实可以看出，使用向zookeeper订阅服务，尽管客户端想获取可用服务节点列表时，不用每次都向zookeeper查询，但是如果数据节点发生变更时，还会再重新请求zookeeper的。如果没有发生变更，那就直接可以使用缓存列表的节点。</p>
<p>Java使用ZKClient的<code>subscribeChildChanges</code>类订阅指定数据节点。可以订阅根节点“/root”，那么每当子节点数据发生变更时，说明netty服务器数量发生变更，就可以返回客户端最新的服务器节点列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//监听zookeeper的“/root”根节点</span><br><span class="line">public void subscribeEvent(String path) &#123;</span><br><span class="line">        zkClient.subscribeChildChanges(path, new IZkChildListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handleChildChange(String parentPath, List&lt;String&gt; currentChilds) throws Exception &#123;</span><br><span class="line">								</span><br><span class="line">                //更新所有缓存，先删除再新增</span><br><span class="line">                serverCache.updateCache(currentChilds) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>   4、负载均衡</p>
<p>客户端现在每次连接时，可以直接从LoadingCache中获取。问题是怎么能均衡地连接列表的服务器节点。</p>
<p>先从最简单解决方法开始，使用“取模“，每次客户端连接，获取LoadingCache的服务器列表时，计数器值+1，然后对列表长度取模得到索引，然后返回该索引对应的服务器节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//负载均衡第一种实现</span><br><span class="line"></span><br><span class="line">//使用原子计数器</span><br><span class="line">private AtomicLong index = new AtomicLong();</span><br><span class="line">public String balance() &#123;</span><br><span class="line">				//CacheUtil的getAll方法</span><br><span class="line">        List&lt;String&gt; all = getAll();</span><br><span class="line">        if (all.size() == 0) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;CIM 服务器可用服务列表为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Long position = index.incrementAndGet() % all.size();</span><br><span class="line">        if (position &lt; 0) &#123;</span><br><span class="line">            position = 0L;</span><br><span class="line">        &#125;</span><br><span class="line">        return all.get(position.intValue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 本质上其实是”轮询“，当客户端连接数量少时，服务器的负载比较均衡，性能也比较快。但是当客户端连接千万级并发量时，取模过程毕竟有线程的竞争，性能会有影响。并且，服务器的上线下线，也会影响负载均衡。</p>
<p>这是在单机实现的负载均衡的服务，如果在分布式集群中，实现负载均衡的服务的机器是集群的话，由于请求是不均匀的，请求负载均衡的服务也是不均衡的，这样就不能保证服务器列表的负载均衡了。</p>
<blockquote>
<p>在解决分布式集群的负载均衡上，可以使用一致性Hash算法。</p>
</blockquote>
<p>一致性hash算法中，根据算法的值构成一个hash环。每次有一个请求绑定的key，对key进行一次hash运算，同样对每个服务器ip或主机名也会做一次hash运算，然后将两种hash值映射到hash环中。</p>
<p><img src="/max.github.io/2020/04/06/netty集群的一次实践/three.png" alt="three"></p>
<ul>
<li>请求经过hash运算后，然后映射到对应的位置，那么对应负载的服务器节点就是顺时针的第一个节点。</li>
<li>当有服务器节点删除时，之前对应的请求会负载到该节点按照顺时针的下一个节点。</li>
<li>新增节点也是一样。</li>
</ul>
<p>这里存在一个问题，可能由于删除的节点负载了大量的请求，这样导致下一个节点负载更多的请求，会造成一定的负载不均衡。</p>
<p>引入”虚拟节点“：对同一个服务器进行多次hash，得到的hash值分布在hash环中，这些节点就称为”虚拟节点”。一般可以在服务器ip后面添加编号，然后进行hash得到虚拟节点。</p>
<p><img src="/max.github.io/2020/04/06/netty集群的一次实践/four.png" alt="four"></p>
<p>这样可以解决当有节点删除时，减少大量请求负载在某个节点上面。当然，最终请求如果映射到某个虚拟节点上，还是需要将虚拟节点转为真实的节点连接。</p>
<blockquote>
<p>Java实现一致性hash算法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">public class ConsistentHashingBalance &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 集群地址列表</span><br><span class="line">     */</span><br><span class="line">    private static String[] groups = &#123;</span><br><span class="line">        &quot;127.0.0.1:8081&quot;, &quot;127.0.0.1:8082&quot;, &quot;127.0.0.1:8083&quot;,</span><br><span class="line">        &quot;127.0.0.1:8084&quot;, &quot;127.0.0.1:8085&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 真实集群列表</span><br><span class="line">     */</span><br><span class="line">    private static List&lt;String&gt; realGroups = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 虚拟节点映射关系</span><br><span class="line">     */</span><br><span class="line">    private static SortedMap&lt;Integer, String&gt; virtualNodes = new TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		//虚拟节点数量</span><br><span class="line">    private static final int VIRTUAL_NODE_NUM = 1000;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        // 先添加真实节点列表</span><br><span class="line">        realGroups.addAll(Arrays.asList(groups));</span><br><span class="line"></span><br><span class="line">        // 将虚拟节点映射到Hash环上</span><br><span class="line">        for (String realGroup: realGroups) &#123;</span><br><span class="line">            for (int i = 0; i &lt; VIRTUAL_NODE_NUM; i++) &#123;</span><br><span class="line">                String virtualNodeName = getVirtualNodeName(realGroup, i);</span><br><span class="line">                int hash = HashUtil.getHash(virtualNodeName);</span><br><span class="line">                System.out.println(&quot;[&quot; + virtualNodeName + &quot;] launched @ &quot; + hash);</span><br><span class="line">               	//放到hash环中</span><br><span class="line">                virtualNodes.put(hash, virtualNodeName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	//通过在真实ip后面加“&amp;&amp;VN&quot;+数字得到虚拟节点ip</span><br><span class="line">    private static String getVirtualNodeName(String realName, int num) &#123;</span><br><span class="line">        return realName + &quot;&amp;&amp;VN&quot; + String.valueOf(num);</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">	//得到虚拟节点对应的真实ip</span><br><span class="line">    private static String getRealNodeName(String virtualName) &#123;</span><br><span class="line">        return virtualName.split(&quot;&amp;&amp;&quot;)[0];</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">		//负载均衡得到服务器ip</span><br><span class="line">    private static String getServer(String key) &#123;</span><br><span class="line">        int hash = HashUtil.getHash(key);</span><br><span class="line">        // 只取出所有大于该hash值的部分而不必遍历整个Tree</span><br><span class="line">        SortedMap&lt;Integer, String&gt; subMap = virtualNodes.tailMap(hash);</span><br><span class="line">        String virtualNodeName;</span><br><span class="line">        if (subMap == null || subMap.isEmpty()) &#123;</span><br><span class="line">            // hash值在最尾部，应该映射到第一个group上</span><br><span class="line">            virtualNodeName = virtualNodes.get(virtualNodes.firstKey());</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            virtualNodeName = subMap.get(subMap.firstKey());</span><br><span class="line">        &#125;</span><br><span class="line">        return getRealNodeName(virtualNodeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 生成随机数进行测试</span><br><span class="line">        Map&lt;String, Integer&gt; resMap = new HashMap&lt;&gt;();</span><br><span class="line">				//一百万个测试连接</span><br><span class="line">        for (int i = 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">            Integer widgetId = i;</span><br><span class="line">            String group = getServer(widgetId.toString());</span><br><span class="line">            if (resMap.containsKey(group)) &#123;</span><br><span class="line">                resMap.put(group, resMap.get(group) + 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resMap.put(group, 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resMap.forEach(</span><br><span class="line">            (k, v) -&gt; &#123;</span><br><span class="line">                System.out.println(&quot;group &quot; + k + &quot;: &quot; + v + &quot;(&quot; + v/10000.0D +&quot;%)&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/max.github.io/2020/04/06/netty集群的一次实践/five.png" alt="five"></p>
<p>结果如上图所示，负载几乎均衡了。当服务器有新增和删除时，也是比较均衡的，这里就不测试了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/max.github.io/2020/03/29/心跳连接分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/max.github.io/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/max.github.io/2020/03/29/心跳连接分析/" itemprop="url">心跳连接分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-29T21:42:13+08:00">
                2020-03-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/max.github.io/categories/netty/" itemprop="url" rel="index">
                    <span itemprop="name">netty</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h5><p>主要针对tcp的长连接，客户端和服务端某一方可能会突然断开连接，为了防止断线造成传输的影响，服务端客户端会每隔一定时间发送tcp数据包，检查连接是否正常，这就是心跳检验机制。</p>
<blockquote>
<p>tcp心跳包还有一个作用，一个连接长时间不用，防火墙或路由器就会断开连接。</p>
</blockquote>
<h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><p><strong>IdleStateHandler</strong> </p>
<p>这个类是继承于ChannelDuplexHandler，继承ChannelInboundHandlerAdapter入站类，和实现了 ChannelOutboundHandler出站类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public IdleStateHandler(long readerIdleTime, long writerIdleTime, long allIdleTime, TimeUnit unit)</span><br></pre></td></tr></table></figure>

<p>构造方法有四个重要的参数，<code>readerIdleTime</code>指服务端多久没读就发送心跳包，<code>writerIdleTime</code>指服务端多久没写就发送心跳包，<code>allIdleTime</code>指服务端多久没读写就发送心跳包，<code>TimeUnitunit</code>指时间的单位。</p>
<p>首先，在服务端Bootstrap的childHandler方法设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                 ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                 pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>, TimeUnit.SECONDS));</span><br><span class="line">                 <span class="comment">//当IdleStateEvent触发后，会由pipeline下一个handler处理事件</span></span><br><span class="line">                 pipeline.addLast(<span class="string">"heartbearhandler"</span>,<span class="keyword">new</span> HeartBeatHandler());</span><br><span class="line">            &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<p>然后，创建HeartBeatHandler自定义handler处理器类，还要实现  userEventTriggered(ChannelHandlerContext ctx, Object evt)方法，<br>event状态有三种，READER_IDLE读超时、WRITER_IDLE写超时、ALL_IDLE读\写超时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent)&#123;</span><br><span class="line">            IdleStateEvent event =(IdleStateEvent) evt;</span><br><span class="line">            String eventType=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (event.state())&#123;</span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                    eventType=<span class="string">"读空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    eventType=<span class="string">"写空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                    eventType=<span class="string">"读写空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress()+<span class="string">"---超时事件----"</span>+eventType+System.currentTimeMillis());</span><br><span class="line">            System.out.println(<span class="string">"服务器做相应处理------"</span>);</span><br><span class="line">            <span class="keyword">if</span>(eventType==<span class="keyword">null</span>)&#123;</span><br><span class="line">                ctx.channel().close();</span><br><span class="line">            &#125;</span><br><span class="line"> &#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><p>在childHandler()方法中，当服务端和客户端连接时，生成NioSocketChannel对象，然后在通道的pipeline中加入了IdleStateHandler处理器对象，自定义的HeartBeatHandler处理器对象。</p>
<blockquote>
<p>看下IdleStateHandler类内部</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public IdleStateHandler(boolean observeOutput, long readerIdleTime, long writerIdleTime, long allIdleTime, TimeUnit unit) &#123;</span><br><span class="line">				//创建一个异步通道监听器对象ChannelFutureListner，重写operationComplete方法</span><br><span class="line">        this.writeListener = new ChannelFutureListener() &#123;</span><br><span class="line">         public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">           //赋值lastWriter属性，值为当前系统时间</span><br><span class="line">            IdleStateHandler.this.lastWriteTime = IdleStateHandler.this.ticksInNanos();</span><br><span class="line">           //赋值firstWriterIdleEvent(首次写超时事件)、firstAllIdleEvent(首次读写超时事件)为true</span><br><span class="line">           IdleStateHandler.this.firstWriterIdleEvent=</span><br><span class="line">            	   IdleStateHandler.this.firstAllIdleEvent = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //赋值firstReaderIdleEvent首次读超时事件为true</span><br><span class="line">        this.firstReaderIdleEvent = true;</span><br><span class="line">        this.firstWriterIdleEvent = true;</span><br><span class="line">        this.firstAllIdleEvent = true;</span><br><span class="line">        if (unit == null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;unit&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        		//赋值出站方法超时标志属性，默认为flase</span><br><span class="line">        		//这个属性，主要是检测当发生写超时事件时，看是否是出站方法导致的超时</span><br><span class="line">            this.observeOutput = observeOutput;</span><br><span class="line">            //依次赋值读超时属性、写超时属性、读写超时属性</span><br><span class="line">            if (readerIdleTime &lt;= 0L) &#123;</span><br><span class="line">                this.readerIdleTimeNanos = 0L;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.readerIdleTimeNanos = Math.max(unit.toNanos(readerIdleTime), MIN_TIMEOUT_NANOS);</span><br><span class="line">            &#125;</span><br><span class="line">            if (writerIdleTime &lt;= 0L) &#123;</span><br><span class="line">                this.writerIdleTimeNanos = 0L;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.writerIdleTimeNanos = Math.max(unit.toNanos(writerIdleTime), MIN_TIMEOUT_NANOS);</span><br><span class="line">            &#125;</span><br><span class="line">            if (allIdleTime &lt;= 0L) &#123;</span><br><span class="line">                this.allIdleTimeNanos = 0L;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.allIdleTimeNanos = Math.max(unit.toNanos(allIdleTime), MIN_TIMEOUT_NANOS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再来看一个方法handlerAdded</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        if (ctx.channel().isActive() &amp;&amp; ctx.channel().isRegistered()) &#123;</span><br><span class="line">            this.initialize(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是最高级ChannelHandler接口的方法，字面上看就是当把handler对象加入到pipeline中时执行的，看下源码。</p>
<p>追朔到最开始应该是客户端连接通道对象NioSocketChannel生成后，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.childGroup.register(child).addListener(new ChannelFutureListener() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>将NioSocketChannel注册到childGroup的一个NioEventLoop线程中，register内部方法执行时，会将NioSocketChannel的childHandler中的ChannelHandler处理器使用addLast()方法加入到pipeline中，其中还会执行this.callHandlerAdded0(newCtx)方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) &#123;</span><br><span class="line">    AbstractChannelHandlerContext newCtx;</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line">        newCtx = this.newContext(group, this.filterName(name, handler), handler);</span><br><span class="line">        //这个就是将handler包装成ChannelHandlerContext，再添加到pipeline中</span><br><span class="line">        this.addLast0(newCtx);</span><br><span class="line">        if (!this.registered) &#123;</span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            this.callHandlerCallbackLater(newCtx, true);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EventExecutor executor = newCtx.executor();</span><br><span class="line">        if (!executor.inEventLoop()) &#123;</span><br><span class="line">            this.callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		//还会执行这个方法</span><br><span class="line">    this.callHandlerAdded0(newCtx);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行内部方法到这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final void callHandlerAdded() throws Exception &#123;</span><br><span class="line">    if (this.setAddComplete()) &#123;</span><br><span class="line">    		//当前handler就是 IdleStateHandler，执行其中的handlerAdded方法</span><br><span class="line">        this.handler().handlerAdded(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>转了一圈，回到了handlerAdded方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">    if (ctx.channel().isActive() &amp;&amp; ctx.channel().isRegistered()) &#123;</span><br><span class="line">        this.initialize(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看initialize方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void initialize(ChannelHandlerContext ctx) &#123;</span><br><span class="line">    switch(this.state) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">    case 2:</span><br><span class="line">        return;</span><br><span class="line">    //刚开始state值为0，所以会执行default</span><br><span class="line">    default:</span><br><span class="line">        this.state = 1;</span><br><span class="line">        //检查出站超时带来的影响</span><br><span class="line">        this.initOutputChanged(ctx);</span><br><span class="line">        //重新赋值lastReadTime、lastWriteTime为当前时间</span><br><span class="line">        this.lastReadTime = this.lastWriteTime = this.ticksInNanos();</span><br><span class="line">        //这里面使用了schedule线程方法，传入IdleStateHandler的task方法，返回的是一个线程异步执行的         //结果</span><br><span class="line">        if (this.readerIdleTimeNanos &gt; 0L) &#123;</span><br><span class="line">            this.readerIdleTimeout = this.schedule(ctx, new IdleStateHandler.ReaderIdleTimeoutTask(ctx), this.readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.writerIdleTimeNanos &gt; 0L) &#123;</span><br><span class="line">            this.writerIdleTimeout = this.schedule(ctx, new IdleStateHandler.WriterIdleTimeoutTask(ctx), this.writerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.allIdleTimeNanos &gt; 0L) &#123;</span><br><span class="line">            this.allIdleTimeout = this.schedule(ctx, new IdleStateHandler.AllIdleTimeoutTask(ctx), this.allIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下IdleStateHandler的内部抽象类AbstractIdleTask</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private abstract static class AbstractIdleTask implements Runnable &#123;</span><br><span class="line">    private final ChannelHandlerContext ctx;</span><br><span class="line"></span><br><span class="line">    AbstractIdleTask(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        //绑定属性IdleStateHandlerContext实例</span><br><span class="line">        this.ctx = ctx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (this.ctx.channel().isOpen()) &#123;</span><br><span class="line">            //run方法内部要实现这个抽象类的run方法执行</span><br><span class="line">            this.run(this.ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    protected abstract void run(ChannelHandlerContext var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这个<code>public void run(){}</code>方法就是模板方法设计模式的模板方法，抽象类中模板方法规定了执行逻辑，但其中的抽象方法可以由子类实现。</p>
<p>就主要看下AbstractIdleTask子类ReaderIdleTimeoutTask</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private final class ReaderIdleTimeoutTask extends IdleStateHandler.AbstractIdleTask &#123;</span><br><span class="line">    ReaderIdleTimeoutTask(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        super(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">		//重写了run方法</span><br><span class="line">    protected void run(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        //获得读超时属性，我传入的参数是2s</span><br><span class="line">        long nextDelay = IdleStateHandler.this.readerIdleTimeNanos;</span><br><span class="line">        if (!IdleStateHandler.this.reading) &#123;</span><br><span class="line">        	  // 重新计算nextDelay，当前系统时间减去上一次读超时的时间</span><br><span class="line">            nextDelay -= IdleStateHandler.this.ticksInNanos() - IdleStateHandler.this.lastReadTime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (nextDelay &lt;= 0L) &#123;</span><br><span class="line">            IdleStateHandler.this.readerIdleTimeout = IdleStateHandler.this.schedule(ctx, this, IdleStateHandler.this.readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">            boolean first = IdleStateHandler.this.firstReaderIdleEvent;</span><br><span class="line">            IdleStateHandler.this.firstReaderIdleEvent = false;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                IdleStateEvent event = IdleStateHandler.this.newIdleStateEvent(IdleState.READER_IDLE, first);</span><br><span class="line">                IdleStateHandler.this.channelIdle(ctx, event);</span><br><span class="line">            &#125; catch (Throwable var6) &#123;</span><br><span class="line">                ctx.fireExceptionCaught(var6);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            IdleStateHandler.this.readerIdleTimeout = IdleStateHandler.this.schedule(ctx, this, nextDelay, TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面调用方法IdleStateHandler.this.schedule(ctx, this, IdleStateHandler.this.readerIdleTimeNanos, TimeUnit.NANOSECONDS)</p>
<p>this就是当前 ReaderIdleTimeoutTask对象，最后括号内部封装成ScheduledFutureTask对象，this.schedule方法会将这个task加入到scheduledTaskQueue任务队列，由ThreadPerTaskExecutor类执行这个任务。</p>
<p>这个方法返回的就是ScheduledFutureTask异步对象。</p>
<blockquote>
<p>执行任务过程中，直到当前时间使发生读超时，接着执行方法IdleStateHandler.this.newIdleStateEvent(IdleState.READER_IDLE, first)</p>
</blockquote>
<p>然后返回IdleStateEvent对象，即读超时事件对象。</p>
<p>再执行 IdleStateHandler.this.channelIdle(ctx, event)，将读超时事件传进去，最终执行内部方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void invokeUserEventTriggered(Object event) &#123;</span><br><span class="line">    if (this.invokeHandler()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ((ChannelInboundHandler)this.handler()).userEventTriggered(this, event);</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            this.notifyHandlerException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.fireUserEventTriggered(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this.handler()返回的就是我定义的HeartBeatHandler处理器对象，执行重写的userEventTriggered方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;</span><br><span class="line">    if(evt instanceof IdleStateEvent)&#123;</span><br><span class="line">        IdleStateEvent event =(IdleStateEvent) evt;</span><br><span class="line">        String eventType=null;</span><br><span class="line">        switch (event.state())&#123;</span><br><span class="line">            case READER_IDLE:</span><br><span class="line">                eventType=&quot;读空闲&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case WRITER_IDLE:</span><br><span class="line">                eventType=&quot;写空闲&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case ALL_IDLE:</span><br><span class="line">                eventType=&quot;读写空闲&quot;;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这就可以根据发生什么超时事件，进行一些业务处理，比如通过ctx向客户端socket通道写数据并监听，如果没有回复就可以关闭通道等。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/max.github.io/2020/03/22/自定义channelhandler处理器执行客户端请求的过程分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/max.github.io/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/max.github.io/2020/03/22/自定义channelhandler处理器执行客户端请求的过程分析/" itemprop="url">自定义channelhandler处理器执行客户端请求的过程分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-22T21:27:28+08:00">
                2020-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/max.github.io/categories/netty/" itemprop="url" rel="index">
                    <span itemprop="name">netty</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="客户端请求在pipeline中handler处理器的执行过程分析"><a href="#客户端请求在pipeline中handler处理器的执行过程分析" class="headerlink" title="客户端请求在pipeline中handler处理器的执行过程分析"></a>客户端请求在pipeline中handler处理器的执行过程分析</h5><h6 id="1、回顾下服务器接收请求的过程"><a href="#1、回顾下服务器接收请求的过程" class="headerlink" title="1、回顾下服务器接收请求的过程"></a>1、回顾下服务器接收请求的过程</h6><ul>
<li><p>NioServerSocketChannel注册到一个NioEventLoop线程中，会监听这个通道，如果监听到事件发生，在<code>processSelectedKeys()</code>方法中处理。</p>
</li>
<li><p>这个方法内部判断，如果是Accept事件，调用 <code>unsafe.read()</code>方法。其中， <code>doReadMessages(List&lt;Object&gt; buf)</code> 方法使用<code>SocketUtils.accept()</code>生成客户端连接通道对象SoketChannel，添加到buf集合中。</p>
</li>
<li><p><code>unfase.read()</code>接着遍历buf集合， 将每个客户端连接通道对象传NioServerSocketChannel的pipeline对象中，执行方法<code>pipeline.fireChannelRead(this.readBuf.get(i))</code>。</p>
</li>
<li><p><code>fireChannelRead()</code>方法中。之前在netty启动过程已经将NioServerSocketChannel的pipeline，设置ChannelHandlerContext双向链表，包含的节点是：head内部类头节点——》LoggingHandler处理器构成的一个节点——》ServerBootstrap.ServerBootstrapAcceptor处理器构成的一个节点——》tail内部类尾节点。</p>
<p><code>fireChannelRead()</code>方法内部调用<code>invokeChannelRead(this.findContextInbound(32), msg)</code>方法，会不断执行所有的节点<code>channelRead()</code>方法。当执行到ServerBootstrapAcceptor处理器所在的节点，先得到SocketChannel的pipeline对象，将在服务端代码自定义的handler对象通过addLast()方法加到pipeline对象中。这样生成的客户端连接通道对象，pipeline中就构建了channelhandler处理器链。最后还要将SocketChannel对象注册到childgroup中一个NioEventLoop线程，并添加监视器。<code>this.childGroup.register(child).addListener()</code> 。</p>
</li>
<li><p>这节分析的就是客户端连接通道对象，在pipeline中怎么执行我们自定义的channelhandler。</p>
</li>
</ul>
<h6 id="2、NioSocketChannel通道处理事件的过程"><a href="#2、NioSocketChannel通道处理事件的过程" class="headerlink" title="2、NioSocketChannel通道处理事件的过程"></a>2、NioSocketChannel通道处理事件的过程</h6><p>当把NioSocketChannel通道注册到workgroup的eventloop线程，其实和NioServerSocketChannel通道处理客户端事件一样，也会在eventloop线程中监听客户端的事件    </p>
<ul>
<li><p>NioEventLoop中run()方法的<code>this.processSelectedKeys()</code>方法，其内部调用<code>this.processSelectedKeysOptimized()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysOptimized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里selectedKeys大小为一，即一个客户端连接事件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.selectedKeys.size; ++i) &#123;</span><br><span class="line">        SelectionKey k = <span class="keyword">this</span>.selectedKeys.keys[i];</span><br><span class="line">        <span class="keyword">this</span>.selectedKeys.keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//attachment()返回的是NioSocketChannel客户端连接通道对象</span></span><br><span class="line">        Object a = k.attachment();</span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">            <span class="comment">//再调用这个方法</span></span><br><span class="line">            <span class="keyword">this</span>.processSelectedKey(k, (AbstractNioChannel)a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            NioTask&lt;SelectableChannel&gt; task = (NioTask)a;</span><br><span class="line">            processSelectedKey(k, task);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.needsToSelectAgain) &#123;</span><br><span class="line">            <span class="keyword">this</span>.selectedKeys.reset(i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.selectAgain();</span><br><span class="line">            i = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后的逻辑就和NioServerSocketChannel的处理一样，监听到Accept事件，执行unsafe.read()方法，然后依次执行SocketChannel的pipeline中的ChannelHandlerContext的<code>channelRead()</code>方法，比如我们自定义了EchoServerHandler类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span>  <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.write(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完ChannelHandlerContext链的头节点后，就执行EchoServerHandler的节点，channelRead()方法就会执行我们重写的方法。<br>当然，后面还可以依次执行每个节点的channelReadComplete方法。包括出现异常时执行 exceptionCaught    方法。</p>
</li>
</ul>
<h6 id="3、小节"><a href="#3、小节" class="headerlink" title="3、小节"></a>3、小节</h6><p>​其实把NioSocketChannel注册到NioEventLoop线程后，处理客户端的事件和        NioServerSocketChannel处理连接事件一样。需要注意的是：两个通道对象一个是在    bossgroup的线程中注册，一个是在workgroup中线程注册。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/max.github.io/2020/03/09/netty接受客户端请求过程分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/max.github.io/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/max.github.io/2020/03/09/netty接受客户端请求过程分析/" itemprop="url">netty接受客户端请求过程分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-09T18:44:44+08:00">
                2020-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/max.github.io/categories/netty/" itemprop="url" rel="index">
                    <span itemprop="name">netty</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="netty服务器接受请求过程"><a href="#netty服务器接受请求过程" class="headerlink" title="netty服务器接受请求过程"></a>netty服务器接受请求过程</h4><blockquote>
<p>回顾netty的启动过程中，最后是bossgroup的NioEventLoop线程会监听ServerSocketChannel这个通道，如果有事件发生，使用<code>processSelectedKeys()</code> 方法处理事件，最后还要处理消息队列中的所有任务 <code>this.runAllTasks()</code>。</p>
</blockquote>
<p><code>processSelectedKey(SelectionKey k, AbstractNioChannel ch)</code>是<code>processSelectedKeys()</code>内部调用核心方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当服务器在通道上监听到事件就会执行这个方法，当然这个方法是bossgroup的nioEventLoop线程下执行的</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//unsafe是这个类AbstractNioMessageChannel$NioMessageUnsafe的实例</span></span><br><span class="line">    NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">    <span class="keyword">if</span> (!k.isValid()) &#123;</span><br><span class="line">        NioEventLoop eventLoop;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">       		<span class="comment">//获得bossgroup的nioEventLoop</span></span><br><span class="line">            eventLoop = ch.eventLoop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eventLoop == <span class="keyword">this</span> &amp;&amp; eventLoop != <span class="keyword">null</span>) &#123;</span><br><span class="line">            unsafe.close(unsafe.voidPromise());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">//readyOps就是事件类型对应的值</span></span><br><span class="line">            <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; <span class="number">8</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">                ops &amp;= -<span class="number">9</span>;</span><br><span class="line">                k.interestOps(ops);</span><br><span class="line">                unsafe.finishConnect();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                ch.unsafe().forceFlush();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; <span class="number">17</span>) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果是连接Accept事件就会执行unsafe的read方法</span></span><br><span class="line">                unsafe.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException var7) &#123;</span><br><span class="line">            unsafe.close(unsafe.voidPromise());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/max.github.io/2020/03/09/netty接受客户端请求过程分析/netty-2.png" alt="netty-2"></p>
<p>浏览器访问服务器端口，经过debug可以看到readyOps值是16，在SelectionKey这个类中，</p>
<ol>
<li>读事件是 <code>OP_READ = 1 &lt;&lt; 0</code>值为1</li>
<li>写事件是<code>OP_WRITE = 1 &lt;&lt; 2</code>值为4  </li>
<li>连接事件是<code>OP_CONNECT = 1 &lt;&lt; 3</code>值为8</li>
<li>接收事件是<code>OP_ACCEPT = 1 &lt;&lt; 4</code>值为16</li>
</ol>
<blockquote>
<p>然后进入了unsafe.read（）方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> AbstractNioMessageChannel.<span class="keyword">this</span>.eventLoop().inEventLoop();</span><br><span class="line">    ChannelConfig config = AbstractNioMessageChannel.<span class="keyword">this</span>.config();</span><br><span class="line">    <span class="comment">//获得NioServerSocketChannel的pipeline</span></span><br><span class="line">    ChannelPipeline pipeline = AbstractNioMessageChannel.<span class="keyword">this</span>.pipeline();</span><br><span class="line">    Handle allocHandle = AbstractNioMessageChannel.<span class="keyword">this</span>.unsafe().recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line">    <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line">    Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> localRead;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">            	<span class="comment">//AbstractNioMessageChannel.this就是NioServerSocketChannel，调用了doReadMessages</span></span><br><span class="line">            	<span class="comment">//方法，并且传入了一个readBuf参数</span></span><br><span class="line">                localRead = AbstractNioMessageChannel.<span class="keyword">this</span>.doReadMessages(<span class="keyword">this</span>.readBuf);</span><br><span class="line">                <span class="keyword">if</span> (localRead == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (localRead &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    closed = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                allocHandle.incMessagesRead(localRead);</span><br><span class="line">            &#125; <span class="keyword">while</span>(allocHandle.continueReading());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var11) &#123;</span><br><span class="line">            exception = var11;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        localRead = <span class="keyword">this</span>.readBuf.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; localRead; ++i) &#123;</span><br><span class="line">            AbstractNioMessageChannel.<span class="keyword">this</span>.readPending = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//NioServerSocketChannel的pipeline，执行fireChannleRead(),传入了readBuf</span></span><br><span class="line">            pipeline.fireChannelRead(<span class="keyword">this</span>.readBuf.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.readBuf.clear();</span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">            closed = AbstractNioMessageChannel.<span class="keyword">this</span>.closeOnReadError(exception);</span><br><span class="line">            pipeline.fireExceptionCaught(exception);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">            AbstractNioMessageChannel.<span class="keyword">this</span>.inputShutdown = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (AbstractNioMessageChannel.<span class="keyword">this</span>.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.close(<span class="keyword">this</span>.voidPromise());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!AbstractNioMessageChannel.<span class="keyword">this</span>.readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.removeReadOp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重点看下这个方法 localRead = AbstractNioMessageChannel.this.doReadMessages(this.readBuf)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//SocketUtils.accept方法产生了一个客户端连接通道SocketChannel！</span></span><br><span class="line">    SocketChannel ch = SocketUtils.accept(<span class="keyword">this</span>.javaChannel());</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="comment">//this就是NioServerSocketChannel，和SocketChannel封装在一起，添加到list中</span></span><br><span class="line">        	<span class="comment">//list就是最开始的unsafe【AbstractNioMessageChannel$NioMessageUnsafe】实例的readbuf</span></span><br><span class="line">            buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Failed to create a new channel from an accepted socket."</span>, var6);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Failed to close a socket."</span>, var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SocketUtils.accept()返回的不就是我们想要客户端连接通道吗！得到了这个通道，接下来就是处理这个连接事件。处理客户端通道的连接事件在<code>pipeline.fireChannelRead(this.readBuf.get(i))</code>方法中。</p>
<blockquote>
<p>pipeline.fireChannelRead(this.readBuf.get(i))，这个方法，先得到NioServerSocketChannel的pipeline，然后调用fireChannelRead方法，传入readBuf，里面是封装了serversocketchannel和socketchannle的NioSocketChannel（在上面的doReadMessage方法中创建的）</p>
</blockquote>
<p>这个方法里面是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final ChannelPipeline fireChannelRead(Object msg) &#123;</span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelRead(this.head, msg);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invokeChannelRead方法传入了两个参数，this是NioServerSocketChannel的pipeline，之前在netty启动过程中分析了serversocketchannel的pipeline，包含了由ChannelHandlerContext构成的双链表结构，结构是：head内部类头节点——&gt;LoggingHandler处理器构成的一个节点——&gt;ServerBootstrap.ServerBootstrapAcceptor处理器构成的一个节点——&gt;tail内部类尾节点。</p>
<blockquote>
<p>this.head就是pipeline的head节点，msg就是NioSocketChannel。</p>
</blockquote>
<p>再看方法内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokeChannelRead(this.findContextInbound(32), msg)</span><br></pre></td></tr></table></figure>

<p>一直追下去，直到这个方法，this是Head头节点，findContext方法干了什么呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private AbstractChannelHandlerContext findContextInbound(int mask) &#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = this;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        ctx = ctx.next;</span><br><span class="line">    &#125; while((ctx.executionMask &amp; mask) == 0);</span><br><span class="line"></span><br><span class="line">    return ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是next()方法获得下一个节点，下一个节点就是LoggingHandler的节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">    if (this.logger.isEnabled(this.internalLevel)) &#123;</span><br><span class="line">        this.logger.log(this.internalLevel, this.format(ctx, &quot;READ&quot;, msg));</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.fireChannelRead(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到执行完又执行了fireChannelRead方法，又是循环，下一个节点是ServerBootstrap.ServerBootstrapAcc</p>
<p>-eptor处理器构成的节点。这个Handler处理过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">    //得到NioSocketChannel</span><br><span class="line">    final Channel child = (Channel)msg;</span><br><span class="line">    /**</span><br><span class="line">    *向NioSocketChannel的pipeline加入处理器！</span><br><span class="line">    *this是ServerBootstrap的内部类ServerBootstrapAcceptor</span><br><span class="line">    *childHandler就是我们之前实现了ChannelInitializer类，在里面添加了自定义的channelhandler！！</span><br><span class="line">    **/</span><br><span class="line">    child.pipeline().addLast(new ChannelHandler[]&#123;this.childHandler&#125;);</span><br><span class="line">    AbstractBootstrap.setChannelOptions(child, this.childOptions, ServerBootstrap.logger);</span><br><span class="line">    AbstractBootstrap.setAttributes(child, this.childAttrs);</span><br><span class="line">    try &#123;</span><br><span class="line">    	//到这里发现了客户端连接通道是childGroup线程组注册的</span><br><span class="line">        this.childGroup.register(child).addListener(new ChannelFutureListener() &#123;</span><br><span class="line">            public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">                if (!future.isSuccess()) &#123;</span><br><span class="line">                    ServerBootstrap.ServerBootstrapAcceptor.forceClose(child, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; catch (Throwable var5) &#123;</span><br><span class="line">        forceClose(child, var5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>child.pipeline().addLast(new ChannelHandler[]{this.childHandler})，这个方法成功的将我们自定义的handler处理器添加到NioSocketChannel的pipeline中，就能读写客户端发送的数据了！</p>
</blockquote>
<p>还没有完，接着this.childGroup是最开始自定义的workgroup，包含了8个NioEventLoop线程。然后将NioSocketChannel注册到这个workgroup中，使用workgroup线程组执行客户端连接，不就是最开始说的服务器接收到客户端连接后，使用workgroup处理连接吗！当然，还加了一个Listener监听器。</p>
<p>【childgroup.register()的逻辑和启动过程中bossgroup.register(NioServerSocketChannel)逻辑相同，这里就不赘述了。】</p>
<p>至此netty启动过程和接受请求过程粗略地分析了一遍，肯定还有很多细节没分析，等之后再花功夫把细节完善下。后面就是看pipeline管道的handler处理器是怎么依次执行的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/max.github.io/2020/03/01/netty启动过程分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/max.github.io/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/max.github.io/2020/03/01/netty启动过程分析/" itemprop="url">netty启动过程分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-01T19:20:10+08:00">
                2020-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/max.github.io/categories/netty/" itemprop="url" rel="index">
                    <span itemprop="name">netty</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="netty的启动过程"><a href="#netty的启动过程" class="headerlink" title="netty的启动过程"></a>netty的启动过程</h4><ol>
<li><p><strong>创建线程组</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = new NioEventLoopGroup(1);</span><br><span class="line">EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br></pre></td></tr></table></figure>

<p>bossGroup线程组用来监听客户端的连接，workerGroup线程组用来处理客户端连接通道。</p>
<blockquote>
<p>new NioEventLoopGroup()设置断点</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public NioEventLoopGroup() &#123;</span><br><span class="line">    this(0);</span><br><span class="line">&#125;</span><br><span class="line">—— ——&gt;继续into</span><br><span class="line">public NioEventLoopGroup(int nThreads) &#123;</span><br><span class="line">        this(nThreads, (Executor)null);</span><br><span class="line">&#125;</span><br><span class="line">—— ——&gt;</span><br><span class="line">//到这里，又传入了两个参数，线程执行器executor和nio的选择器selector</span><br><span class="line">public NioEventLoopGroup(int nThreads, Executor executor) &#123;</span><br><span class="line">        this(nThreads, executor, SelectorProvider.provider());</span><br><span class="line">&#125;</span><br><span class="line">—— ——&gt;</span><br><span class="line">//重要的参数改变了，如果传入线程数==0，则设为DEFAULT_EVENT_LOOP_THREADS，</span><br><span class="line">  否则线程数就是构造器传入的</span><br><span class="line">//并传给父类MultithreadEventExecutorGroup构造器方法</span><br><span class="line">protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) &#123;</span><br><span class="line">        super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">&#125;</span><br><span class="line">//默认的线程数是cpu数*2</span><br><span class="line">DEFAULT_EVENT_LOOP_THREADS=Math.max(1,SystemPropertyUtil.getInt(&quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors()*2));</span><br><span class="line">—— ——&gt;</span><br><span class="line"> //这个里面的方法才是真正创建线程组的</span><br><span class="line"> protected MultithreadEventExecutorGroup(int nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args)&#123;</span><br><span class="line"> 	...</span><br><span class="line"> 	//给executor赋值，创建ThreadPerTaskExecutor类实例</span><br><span class="line"> 	 if (executor == null) &#123;</span><br><span class="line">          executor = new ThreadPerTaskExecutor(this.newDefaultThreadFactory());</span><br><span class="line">      &#125;</span><br><span class="line">    //创建线程组，EventExecutor是接口Executor的实现类</span><br><span class="line">    this.children = new EventExecutor[nThreads];</span><br><span class="line">    for(int i = 0; i &lt; nThreads; ++i) &#123;</span><br><span class="line">	....</span><br><span class="line">	try&#123;</span><br><span class="line">		//使用new Child()方法，对每个线程赋值</span><br><span class="line">		//new Child()抽象方法，NioEventLoop类重写了，返回NioEventLoop类型</span><br><span class="line">		this.children[i] = this.newChild((Executor)executor, args);</span><br><span class="line">		...</span><br><span class="line">	&#125;catch (Exception var19) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;failed to create a child event loop&quot;, 		var19);</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">                if (var18) &#123;</span><br><span class="line">                      	if (!success) &#123;</span><br><span class="line">                      		//如果某个线程实例时出现了异常，会把之前所有的线程都安全关闭掉</span><br><span class="line">                            int j;</span><br><span class="line">                            for(j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">                                this.children[j].shutdownGracefully();</span><br><span class="line">                            &#125;</span><br><span class="line">                            ...</span><br><span class="line">                        &#125;&#125;&#125;</span><br><span class="line">      ...</span><br><span class="line">	&#125;</span><br><span class="line">	this.chooser = chooserFactory.newChooser(this.children);</span><br><span class="line">    FutureListener&lt;Object&gt; terminationListener = new FutureListener&lt;Object&gt;() &#123;</span><br><span class="line">    public void operationComplete(Future&lt;Object&gt; future) throws Exception &#123;</span><br><span class="line">          if(MultithreadEventExecutorGroup.this.terminatedChildren.incrementAndGet() == 					MultithreadEventExecutorGroup.this.children.length) &#123;</span><br><span class="line">           MultithreadEventExecutorGroup.this.terminationFuture.setSuccess((Object)null);</span><br><span class="line">           &#125;&#125;</span><br><span class="line">      	&#125;;</span><br><span class="line">            EventExecutor[] var24 = this.children;</span><br><span class="line">            j = var24.length;</span><br><span class="line">            //对线程组中的每个NioEventLoop实例增加FutureListener监听器</span><br><span class="line">            for(int var26 = 0; var26 &lt; j; ++var26) &#123;</span><br><span class="line">                EventExecutor e = var24[var26];</span><br><span class="line">                e.terminationFuture().addListener(terminationListener);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ServerBootStrap配置</strong></p>
<p>ServerBootStrap用于服务端引导配置，包括设置线程组、通道类型、通道处理器等。</p>
<blockquote>
<p>new ServerBootStrap()</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	public class ServerBootstrap extends AbstractBootstrap&lt;ServerBootstrap, ServerChannel&gt; &#123;</span><br><span class="line">   private final Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = new ConcurrentHashMap();</span><br><span class="line">   private final Map&lt;AttributeKey&lt;?&gt;, Object&gt; childAttrs = new ConcurrentHashMap();</span><br><span class="line">   private final ServerBootstrapConfig config = new ServerBootstrapConfig(this);</span><br><span class="line">   private volatile EventLoopGroup childGroup;</span><br><span class="line">   private volatile ChannelHandler childHandler;</span><br><span class="line">private static final InternalLogger logger = 	 </span><br><span class="line">                              InternalLoggerFactory.getInstance(ServerBootstrap.class);</span><br><span class="line">   public ServerBootstrap() &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>发现构造器并没做什么，但是类的相关属性都初始化了。</p>
<blockquote>
<p>group(bossgroup,workergroup)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) &#123;</span><br><span class="line">    //AbstracServerBootstrap父类的group方法执行</span><br><span class="line">    super.group(parentGroup);</span><br><span class="line">    ObjectUtil.checkNotNull(childGroup, &quot;childGroup&quot;);</span><br><span class="line">    if (this.childGroup != null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;childGroup set already&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    	//赋值childgroup属性，然后返回实例</span><br><span class="line">        this.childGroup = childGroup;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//AbstracServerBootStrap group方法</span><br><span class="line">public B group(EventLoopGroup group) &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(group, &quot;group&quot;);</span><br><span class="line">    if (this.group != null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;group set already&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    	//赋值group属性</span><br><span class="line">        this.group = group;</span><br><span class="line">        return this.self();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>channel(NioServerSocketChannel.class)</p>
</blockquote>
<p>设置服务端通道类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//使用AbstractServerBootStrap的channel方法，将ReflectiveChannelFactory实例赋给channelFactory属  //性，并且设置ReflectiveChannelFactory实例的construct属性为传进去的channelClass的construct</span><br><span class="line">public B channel(Class&lt;? extends C&gt; channelClass) &#123;</span><br><span class="line">		//使用反射通道工厂设置通道，就是根据class类型反射创建实例</span><br><span class="line">        return this.channelFactory((io.netty.channel.ChannelFactory)(new ReflectiveChannelFactory((Class)ObjectUtil.checkNotNull(channelClass, &quot;channelClass&quot;))));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">//调用到最底层类ReflectiveChannelFactory的构造方法 </span><br><span class="line">public ReflectiveChannelFactory(Class&lt;? extends T&gt; clazz) &#123;</span><br><span class="line">        ObjectUtil.checkNotNull(clazz, &quot;clazz&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">        	//将通道类型的构造器赋值</span><br><span class="line">            this.constructor = clazz.getConstructor();</span><br><span class="line">        &#125; catch (NoSuchMethodException var3) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Class &quot; + StringUtil.simpleClassName(clazz) + &quot; does not have a public non-arg constructor&quot;, var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> //并且将ReflectiveChannelFactory实例赋给AbstractServerBootstrap的channelFactory属性</span><br><span class="line"> public B channelFactory(ChannelFactory&lt;? extends C&gt; channelFactory) &#123;</span><br><span class="line">        ObjectUtil.checkNotNull(channelFactory, &quot;channelFactory&quot;);</span><br><span class="line">        if (this.channelFactory != null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;channelFactory set already&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.channelFactory = channelFactory;</span><br><span class="line">            return this.self();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>option(ChannelOption.SO_BACKLOG,100)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//AbstractBootstrap的方法</span><br><span class="line">public &lt;T&gt; B option(ChannelOption&lt;T&gt; option, T value) &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(option, &quot;option&quot;);</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        this.options.remove(option);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //其实是给optionmap中插入数据</span><br><span class="line">        this.options.put(option, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this.self();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>handler(new LoggingHandler(LogLevel.INFO))</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//AbstractBootstrap的方法，给handler属性赋值</span><br><span class="line">public B handler(ChannelHandler handler) &#123;</span><br><span class="line">        this.handler = (ChannelHandler)ObjectUtil.checkNotNull(handler, &quot;handler&quot;);</span><br><span class="line">        return this.self();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ChannelFuture f = b.bind(port).sync()</strong></p>
<p>最核心的部分，绑定端口并运行服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">—— ——&gt;</span><br><span class="line">//AbstractBootstrap类的bind方法</span><br><span class="line"> public ChannelFuture bind(int inetPort) &#123;</span><br><span class="line">        return this.bind(new InetSocketAddress(inetPort));</span><br><span class="line"> &#125;</span><br><span class="line">—— ——&gt;</span><br><span class="line">public ChannelFuture bind(SocketAddress localAddress) &#123;</span><br><span class="line">        this.validate();</span><br><span class="line">        return this.doBind((SocketAddress)ObjectUtil.checkNotNull(localAddress, &quot;localAddress&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"> —— ——&gt;</span><br><span class="line"> //最底层的方法</span><br><span class="line"> private ChannelFuture doBind(final SocketAddress localAddress) &#123;</span><br><span class="line">        //initAndRegister方法进行初始化和注册</span><br><span class="line">        final ChannelFuture regFuture = this.initAndRegister();</span><br><span class="line">        final Channel channel = regFuture.channel();</span><br><span class="line">        if (regFuture.cause() != null) &#123;</span><br><span class="line">            return regFuture;</span><br><span class="line">        &#125; else if (regFuture.isDone()) &#123;</span><br><span class="line">            ChannelPromise promise = channel.newPromise();</span><br><span class="line">            doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">            return promise;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            final AbstractBootstrap.PendingRegistrationPromise promise = new AbstractBootstrap.PendingRegistrationPromise(channel);</span><br><span class="line">            regFuture.addListener(new ChannelFutureListener() &#123;</span><br><span class="line">                public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">                    Throwable cause = future.cause();</span><br><span class="line">                    if (cause != null) &#123;</span><br><span class="line">                        promise.setFailure(cause);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        promise.registered();</span><br><span class="line">                        //关键bind方法</span><br><span class="line">                        AbstractBootstrap.doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            return promise;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  —— —— —— ——&gt;</span><br><span class="line">  final ChannelFuture initAndRegister() &#123;</span><br><span class="line">        Channel channel = null;</span><br><span class="line">        try &#123;</span><br><span class="line">        	//通过channelFactory通道工厂属性的newChannel方法创建channel</span><br><span class="line">        	/**因为之前已经将flectiveChannelFactory实例赋给channelFactory属性</span><br><span class="line">        	*flectiveChannelFactory的newChannel()方法实现为</span><br><span class="line">        	*  return (Channel)this.constructor.newInstance();</span><br><span class="line">        	* 通过构造器反射创建channel实例，即NioServerSocketChannel实例</span><br><span class="line">        	**/</span><br><span class="line">            channel = this.channelFactory.newChannel();</span><br><span class="line">            this.init(channel);</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            if (channel != null) &#123;</span><br><span class="line">                channel.unsafe().closeForcibly();</span><br><span class="line">                return (new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE)).setFailure(var3);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return (new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE)).setFailure(var3);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		/**</span><br><span class="line">		* 这个方法是将nioServerSocketChannel注册到bossgroup中</span><br><span class="line">		* group()返回是bossgroup，register()先使用next()得到bossgroup的一个线程，然后绑定通道</span><br><span class="line">		*</span><br><span class="line">		**/</span><br><span class="line">        ChannelFuture regFuture = this.config().group().register(channel);</span><br><span class="line">        if (regFuture.cause() != null) &#123;</span><br><span class="line">            if (channel.isRegistered()) &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                channel.unsafe().closeForcibly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return regFuture;</span><br><span class="line">    &#125;</span><br><span class="line">—— —— —— —— ——</span><br><span class="line">//ServerBootStrap类的init方法实现</span><br><span class="line">   void init(Channel channel) &#123;</span><br><span class="line">   		//给channel的config绑定optionmap的键值对</span><br><span class="line">        setChannelOptions(channel, (Entry[])this.options0().entrySet().toArray(newOptionArray(0)), logger);</span><br><span class="line">        setAttributes(channel, (Entry[])this.attrs0().entrySet().toArray(newAttrArray(0)));</span><br><span class="line">        //获得NioServerSocketChannel通道的管道</span><br><span class="line">        ChannelPipeline p = channel.pipeline();</span><br><span class="line">        final EventLoopGroup currentChildGroup = this.childGroup;</span><br><span class="line">        final ChannelHandler currentChildHandler = this.childHandler;</span><br><span class="line">        final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions = (Entry[])this.childOptions.entrySet().toArray(newOptionArray(0));</span><br><span class="line">        final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = (Entry[])this.childAttrs.entrySet().toArray(newAttrArray(0));</span><br><span class="line">        //加入NioServerSocketChannel通道的处理器</span><br><span class="line">        p.addLast(new ChannelHandler[]&#123;new ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">            public void initChannel(final Channel ch) &#123;</span><br><span class="line">                final ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                //获得ServerBootstrap的channelhandler属性</span><br><span class="line">                ChannelHandler handler = ServerBootstrap.this.config.handler();</span><br><span class="line">                if (handler != null) &#123;</span><br><span class="line">                	//如果事先设置，则向NioServerSocketChannel的peipeline尾部添加handler</span><br><span class="line">                	/**</span><br><span class="line">                	 * 这个handler是serverbootstrap的handler()方法的参数，在这里是</span><br><span class="line">                     * logginghandler</span><br><span class="line">                	 **/</span><br><span class="line">                    pipeline.addLast(new ChannelHandler[]&#123;handler&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			/**</span><br><span class="line">			* 这段代码作用是：ch.eventLoop()即bossgroup的线程，向nioServerSocketChannel的</span><br><span class="line">			* pipeline尾部加了ServerBootstrapAcceptor接收器，监听等待客户端的连接</span><br><span class="line">			**/</span><br><span class="line">                ch.eventLoop().execute(new Runnable() &#123;</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        pipeline.addLast(new ChannelHandler[]&#123;new ServerBootstrap.ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ChannelFuture regFuture = this.config().group().register(channel);</p>
</blockquote>
<p>看下initAndRegister()方法中的这行代码，作用是将使用bossgroup线程组注册nioServerSocketChannel通道。其实主要干了两件事：</p>
<p>1、先使用next()获得bossgroup的一个线程，然后execute执行register0(promise)。</p>
<p>​    promise是将NioServerSocketChannel和NioEventLoop封装在一起的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

<p>2、register0(promise)方法最底层调用到了AbstractNioChannel类的doRegister()方法。下面这行代码就是这个方法的核心，这个不就是nio中将选择器注册到通道中吗！当然执行这整个过程都是在bossgroup的eventLoop线程中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.selectionKey = this.javaChannel().register(this.eventLoop().unwrappedSelector(), 0, this);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p><strong>initAndRegister()方法</strong>之后进入到核心方法 <code>AbstractBootstrap.doBind0(regFuture, channel, localAddress, promise)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">—— —— —— ——&gt;</span><br><span class="line">AbstractBootstrap.bind0方法内调用了   </span><br><span class="line">channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line"></span><br><span class="line">—— —— —— ——&gt;</span><br><span class="line">调用到DefaultChannelHandlerPipeline类中的bind(SocketAddress localAddress, ChannelPromise promise)</span><br><span class="line">—— —— —— ——&gt;</span><br><span class="line">调用到AbstractChannelHandlerContext类中的 bind(final SocketAddress localAddress, final ChannelPromise promise) </span><br><span class="line">方法里使用了  next.invokeBind(localAddress, promise);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">—— —— —— ——&gt;</span><br><span class="line">跳出bind方法后会跳到SingleThreadEventExecutor线程类的runAllTasks方法</span><br><span class="line"></span><br><span class="line">—— —— —— ——&gt;</span><br><span class="line">执行完后跳到NioEventLoop类的run()方法</span><br><span class="line">这个方法中有两个很重要的方法</span><br><span class="line">1、this.processSelectedKeys();</span><br><span class="line">2、  this.runAllTasks();</span><br><span class="line">因为之前已经在NioEventLoop中给ServerSocketChannel通道注册了选择器，所以</span><br><span class="line">当有客户端和服务端连接时，NioEventLoop线程监听到连接事件，会让childgroup的线程组执行处理这些连接，并且不断循环监听事件。</span><br></pre></td></tr></table></figure>

<p>这个过程其实很复杂，涉及到线程操作。先进行简单分析。 </p>
</li>
<li><p><strong>NioServerSocketChannel和Pipeline、ChannelHandler、ChannelHandlerContext的关系</strong></p>
<p>在<code>initAndRegister()</code>方法中，使用channelFactory通道工厂给channel赋值生成NioServerSocketChannel实例，channel中相关的属性如下：</p>
<p><img src="/max.github.io/2020/03/01/netty启动过程分析/netty%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90.png" alt="netty启动过程分析"></p>
<blockquote>
<p>包含一个pipeline属性</p>
</blockquote>
<p>pipeline属性初始为DefaultChannelPipeline实例，<code>DefaultChannelPipeline</code>是一个双链表结构，包含head、tail头尾结点，更具体的看head头结点是DefaultChannelPipeline中的HeadContext内部类，tail尾结点是TailContext内部类，并且头尾结点是AbstractChannelHandlerContext类型，从其源码可以应证： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultChannelPipeline implements ChannelPipeline &#123;</span><br><span class="line">//头结点</span><br><span class="line">final AbstractChannelHandlerContext head;</span><br><span class="line">//尾结点</span><br><span class="line">final AbstractChannelHandlerContext tail;</span><br><span class="line">//pipeline也可以获得channel实例</span><br><span class="line">private final Channel channel;</span><br><span class="line"></span><br><span class="line">protected DefaultChannelPipeline(Channel channel) &#123;</span><br><span class="line">    this.channel = (Channel)ObjectUtil.checkNotNull(channel, &quot;channel&quot;);</span><br><span class="line">    this.succeededFuture = new SucceededChannelFuture(channel, (EventExecutor)null);</span><br><span class="line">    this.voidPromise = new VoidChannelPromise(channel, true);</span><br><span class="line">    this.tail = new DefaultChannelPipeline.TailContext(this);</span><br><span class="line">    this.head = new DefaultChannelPipeline.HeadContext(this);</span><br><span class="line">    //初始头结点next指向尾结点，尾结点prev指向头结点</span><br><span class="line">    this.head.next = this.tail;</span><br><span class="line">    this.tail.prev = this.head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">final class HeadContext extends AbstractChannelHandlerContext implements ChannelOutboundHandler, ChannelInboundHandler &#123;...&#125;</span><br><span class="line"></span><br><span class="line">final class TailContext extends AbstractChannelHandlerContext implements ChannelInboundHandler &#123;...&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于channelhandler怎么关联，可以继续看pipeline的方法<code>addLast(String name, ChannelHandler handler)</code> ，有可以不带name参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//调用更底层方法</span><br><span class="line">public final ChannelPipeline addLast(String name, ChannelHandler handler) &#123;</span><br><span class="line">    return this.addLast((EventExecutorGroup)null, name, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) &#123;</span><br><span class="line">	//创建AbstractChannelHanderContext实例</span><br><span class="line">    AbstractChannelHandlerContext newCtx;</span><br><span class="line">    //保证多线程添加的安全</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line">        /**</span><br><span class="line">        * 这个方法返回一个DefaultChannelHandlerContext实例，这个类是AbstractChannelHandler</span><br><span class="line">        * Context的子类，并且多了一个channelhandler属性，将handler赋给channelhandler属性</span><br><span class="line">        **/</span><br><span class="line">        newCtx = this.newContext(group, this.filterName(name, handler), handler);</span><br><span class="line">        //然后将channelhandlercontext添加到tail结点的前面</span><br><span class="line">        this.addLast0(newCtx);</span><br><span class="line">        if (!this.registered) &#123;</span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            this.callHandlerCallbackLater(newCtx, true);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        EventExecutor executor = newCtx.executor();</span><br><span class="line">        if (!executor.inEventLoop()) &#123;</span><br><span class="line">            this.callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.callHandlerAdded0(newCtx);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次使用addLast方法添加channelhandler时，会先创建一个DefaultChannelHandlerContext实例，将channlehandler赋给这个实例的channelhandler属性，然后将这个实例添加到pipeline的尾结点前面。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/max.github.io/page/2/">2</a><a class="extend next" rel="next" href="/max.github.io/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/max.github.io/images/avatar.jpg" alt="Max">
            
              <p class="site-author-name" itemprop="name">Max</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/max.github.io/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/max.github.io/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/max.github.io/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        
<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Max</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/max.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/max.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/max.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/max.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/max.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/max.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/max.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/max.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/max.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/max.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/max.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
